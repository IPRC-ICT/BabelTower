void kmeans_set_zero ( int * means , int size ) { for ( int id = 0 ; id < size ; id ++ ) means [ id ] = 0 ; }
void Mul_half_cpu ( float * src , float * dst ) { for ( int index = 0 ; index < 3 ; index ++ ) { dst [ index ] = src [ index ] * 0.5 ; } }
void resetIndices_cpu ( long * vec_out , const long N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { vec_out [ idx ] = idx ; } }
void set_offset_kernel ( int stride , int size , int * output ) { for ( int i = 0 ; i < size ; i ++ ) { output [ i ] = i * stride ; } }
void setSuppressed_cpu ( int * suppressed , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { suppressed [ tid ] = 0 ; } }
void allDivInplace_cpu ( double * arr , double alpha , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] /= alpha ; } }
void incrementArrayOnHost ( float * a , int N ) { int i ; for ( i = 0 ; i < N ; i ++ ) a [ i ] = a [ i ] + 1.f ; }
void allMulInplace_cpu ( double * arr , double alpha , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] *= alpha ; } }
void Init ( const long long size , const double * in , double * out ) { int i ; for ( i = 0 ; i < size ; i ++ ) out [ i ] = in [ i ] ; }
void subAvg_cpu ( int * input , int count , int avg ) { for ( int index = 0 ; index < count ; index ++ ) { input [ index ] = input [ index ] - avg ; } }
void allExp2Inplace_cpu ( double * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] * 9 ; } }
void vector_add_cpu ( float a [ ] , float b [ ] , float * c ) { for ( int i = 0 ; i < 10000 ; i ++ ) { c [ i ] = a [ i ] + b [ i ] ; } }
void setLabels_cpu ( int * output , int dims , int clsNum ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { output [ tid ] = tid % clsNum ; } }
void histogram_cpu ( int n , int * color , int * bucket ) { for ( int i = 0 ; i < n ; i ++ ) { int c = color [ i ] ; bucket [ c ] += 1 ; } }
void sigmoid_kernel ( float * input , float * output , int n ) { for ( int tid = 0 ; tid < n ; tid ++ ) output [ tid ] = 1 / ( 1 + expf ( - input [ tid ] ) ) ; }
void kernelUpdateHead ( int * head , int * d_idxs_out , int n ) { for ( int i = 0 ; i < n ; i ++ ) { head [ d_idxs_out [ i ] ] = 1 ; } }
void const_cpu ( int N , float ALPHA , float * X , int INCX ) { int i ; for ( i = 0 ; i < N ; ++ i ) X [ i * INCX ] = ALPHA ; }
void allLog2_cpu ( const double * arr , double * buf , int n ) { for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = arr [ i ] / 2 ; } }
void clearArray_cpu ( unsigned char * arr , const unsigned int lenght ) { unsigned int offset ; while ( offset < lenght ) { arr [ offset ] = 0 ; offset += 1 ; } }
void Copy_List_cpu ( const int element_numbers , const float * origin_list , float * list ) { for ( int i = 0 ; i < element_numbers ; i ++ ) { list [ i ] = origin_list [ i ] ; } }
void add ( int n , float * x , float * y ) { for ( int i = 0 ; i < n ; i ++ ) { y [ i ] = x [ i ] + y [ i ] ; } }
void host_add ( float * c , float * a , float * b , int n ) { for ( int k = 0 ; k < n ; k ++ ) { c [ k ] = a [ k ] + b [ k ] ; } }
void subtract_matrix ( float * a , float * b , float * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] - b [ idx ] ; } }
void add_matrix_cpu ( float * a , float * b , float * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] + b [ idx ] ; } }
void vecAdd_cpu ( float * in1 , float * in2 , float * out , int len ) { for ( int i = 0 ; i < len ; i ++ ) { out [ i ] = in1 [ i ] + in2 [ i ] ; } }
void doubleArrayScalarAdd_cpu ( double * d_in , double * d_out , int length , double scalar ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in [ idx ] + scalar ; } }
void add_matrix_cpu ( double * a , double * b , double * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] + b [ idx ] ; } }
void test1_cpu ( float * input , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( input [ tid * 4 ] != 0 ) { input [ tid * 4 ] = 0 ; } } }
void vecAddCPU ( double * pdbA , double * pdbB , double * pdbC ) { for ( int i = 0 ; i < VecSize ; ++ i ) { pdbC [ i ] = pdbA [ i ] + pdbB [ i ] ; } }
void doubleArrayScalarMultiply_cpu ( double * d_in , double * d_out , int length , double scalar ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in [ idx ] * scalar ; } }
void addV_cpu ( int * a , int * b , int * c , int N ) { for ( int index = 0 ; index < N ; index ++ ) { c [ index ] = a [ index ] + b [ index ] ; } }
void VecAdd_cpu ( float * A , float * B , float * C , int N ) { for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = A [ i ] + B [ i ] ; } }
void saxpy_cpu ( float * x , float * y , float alpha , int n ) { for ( int i = 0 ; i < n ; i ++ ) y [ i ] = alpha * x [ i ] + y [ i ] ; }
void sumArrays_cpu ( float * A , float * B , float * C , const int N ) { for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = A [ i ] + B [ i ] ; } }
void doubleArrayScalarSubstract_cpu ( double * d_in , double * d_out , int length , double scalar ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in [ idx ] - scalar ; } }
void doubleArrayElementwiseSquare_cpu ( double * d_in , double * d_out , int length ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in [ idx ] * d_in [ idx ] ; } }
void sumArraysOnHostx ( int * A , int * B , int * C , const int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) C [ idx ] = A [ idx ] + B [ idx ] ; }
void k_vec_divide ( float * vec1 , float * vec2 , int max_size ) { for ( int i = 0 ; i < max_size ; i ++ ) { vec1 [ i ] = vec1 [ i ] / vec2 [ i ] ; } }
void saxpi_c ( int n , float a , float * x , float * y ) { for ( int i = 0 ; i < n ; i ++ ) y [ i ] = a * x [ i ] + y [ i ] ; }
void cpu_record ( float * p , float * seis_kt , int * Gxz , int ng ) { for ( int id = 0 ; id < ng ; id ++ ) { seis_kt [ id ] = p [ Gxz [ id ] ] ; } }
void vectorDiv ( const float * A , const float * B , float * C , int numElements ) { int i ; for ( i = 0 ; i < numElements ; i ++ ) { C [ i ] = A [ i ] / B [ i ] ; } }
void cpuSAXPY ( int len , float a , float * x , float * y ) { for ( int i = 0 ; i < 20000000 ; i ++ ) { y [ i ] = x [ i ] * a + y [ i ] ; } }
void vectorAdd ( const float * A , const float * B , float * C , int numElements ) { int i ; for ( i = 0 ; i < numElements ; i ++ ) { C [ i ] = A [ i ] + B [ i ] ; } }
void vectorAdd ( double * a , double * b , double * c , int vector_size ) { for ( int idx = 0 ; idx < vector_size ; idx ++ ) { c [ idx ] = a [ idx ] + b [ idx ] ; } }
void addIntValues ( int * destination , int * value1 , int * value2 , unsigned int end ) { for ( unsigned int i = 0 ; i < end ; i ++ ) { destination [ i ] = value1 [ i ] + value2 [ i ] ; } }
void histo_cpu ( const unsigned int * const vals , unsigned int * const histo , int numVals ) { int i ; for ( i = 0 ; i < numVals ; i ++ ) histo [ vals [ i ] ] = histo [ vals [ i ] ] + 1 ; }
void vadd ( const float * a , const float * b , float * c , const unsigned int count ) { for ( int i = 0 ; i < count ; i ++ ) { c [ i ] = a [ i ] + b [ i ] ; } }
void subtractIntValues ( int * destination , int * value1 , int * value2 , unsigned int end ) { for ( unsigned int i = 0 ; i < end ; i ++ ) { destination [ i ] = value1 [ i ] + value2 [ i ] ; } }
void transferMBR3_cpu ( double * xy_copy , long long * a_copy , int tasks ) { for ( int i = 0 ; i < tasks ; i ++ ) { a_copy [ i ] = xy_copy [ i ] * 10000000 ; } }
void binarize_cpu ( float * input , int n , float * binary ) { int i ; for ( i = 0 ; i < n ; ++ i ) { binary [ i ] = ( input [ i ] > 0 ) ? 1 : -1 ; } }
void add_vec_scalaire_cpu ( int * vec , int * res , int a , long N ) { int i ; for ( i = 0 ; i < N ; i ++ ) { res [ i ] = vec [ i ] + a ; } }
void memcpy_kernel ( int * dst , int * src , int n ) { for ( int i = 0 ; i < n / sizeof ( int ) ; i ++ ) { dst [ i ] = src [ i ] ; } }
void add_cpu ( int N , int offset , float * X , int INCX ) { int i ; for ( i = 0 ; i < N ; ++ i ) { X [ i * INCX ] += offset ; if ( X [ i * INCX ] == -128 ) X [ i * INCX ] = -127 ; } }
void doubleArraySign_cpu ( double * d_in , double * d_out , int length ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = ( 0 < d_in [ idx ] ) - ( d_in [ idx ] < 0 ) ; } }
void find_max_cpu ( int * data , int N ) { int i , m ; m = data [ 0 ] ; for ( i = 0 ; i < N ; i ++ ) { if ( data [ i ] > m ) m = data [ i ] ; } data [ 0 ] = m ; }
void setOffset_cpu ( int * offset , int dims , int batchSize ) { offset [ 0 ] = 0 ; for ( int i = 1 ; i < batchSize + 1 ; i ++ ) { offset [ i ] = i * dims ; } }
void expandScoreFactors_cpu ( const float * input , float * output , int dims , int clsNum ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { int k = tid / clsNum ; output [ tid ] = input [ k ] ; } }
void kernelIsFirst_cpu ( int * head , int * first_pts , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( head [ i ] == 1 ) first_pts [ i ] = i ; else first_pts [ i ] = 0 ; } }
void sumRowKernel_cpu ( int * d_in , int * d_out , int DIM ) { int sum = 0 ; for ( int i = 0 ; i < DIM ; i ++ ) { sum += d_in [ i ] ; } }
void addVectorsInto_cpu ( float * result , float * a , float * b , int N ) { for ( int i = 0 ; i < N ; i ++ ) { result [ i ] = a [ i ] + b [ i ] ; } }
void setIndexYolov3_cpu ( int * input , int dims , int batchSize ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { for ( int i = 0 ; i < batchSize ; i ++ ) { input [ i * dims + tid ] = tid ; } } }
void shiftIndices ( long * vec_out , const long by , const long imageSize , const long N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { vec_out [ idx ] = ( imageSize + ( ( idx - N / 2 + by ) % imageSize ) ) % imageSize ; } }
void doubleArrayVectorSubstract_cpu ( double * d_in_a , double * d_in_b , double * d_out , int length ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in_a [ idx ] - d_in_b [ idx ] ; } }
void doubleArrayVectorElementwiseMultiply_cpu ( double * d_in_a , double * d_in_b , double * d_out , int length ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in_a [ idx ] * d_in_b [ idx ] ; } }
void fill_idx ( int N , int * device_input , int * device_output ) { int idx ; for ( idx = 0 ; idx + 1 < N ; idx ++ ) { if ( device_input [ idx ] + 1 == device_input [ idx + 1 ] ) device_output [ device_input [ idx ] ] = idx ; } }
void cpuSearchPosShmem1EQ ( int key , int * devKey , int * devPos , int size ) { for ( int globalTx = 0 ; globalTx < size ; globalTx ++ ) { if ( devKey [ globalTx ] == key ) { devPos [ 0 ] = globalTx ; } } }
void mathKernel1 ( float * c , int size ) { int tid ; float ia , ib ; ia = ib = 0.0f ; for ( tid = 0 ; tid < size ; tid ++ ) { if ( tid % 2 == 0 ) { ia = 100.0f ; } else { ib = 200.0f ; } c [ tid ] = ia + ib ; } }
void Reverse ( int * d_in , int * d_out , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { d_out [ i ] = d_in [ size - 1 - i ] ; } }
void gaussianPass ( int patchSize , int dataSize , float * gaussFilter , float * data ) { for ( int i = 0 ; i < dataSize ; i ++ ) { data [ i ] = gaussFilter [ i % ( patchSize * patchSize ) ] * data [ i ] ; } }
void cpuAdd ( int * a , int * b , int * c , int vectorSize ) { int i ; #pragma omp parallel for ENDCOM for ( i = 0 ; i < vectorSize ; i ++ ) { c [ i ] = a [ i ] + b [ i ] ; } }
void clamp_cpu ( int N , float * X , int INCX , float clamp_min , float clamp_max ) { int i ; for ( i = 0 ; i < N ; ++ i ) X [ i * INCX ] = fmin ( clamp_max , fmax ( clamp_min , X [ i * INCX ] ) ) ; }
double histogram_serial ( const int * values , int * bins , const int nbins , const int n ) { double time = - omp_get_wtime ( ) ; for ( int i = 0 ; i < nbins ; ++ i ) { bins [ i ] = 0 ; } for ( int i = 0 ; i < n ; ++ i ) { bins [ values [ i ] ] ++ ; } time += omp_get_wtime ( ) ; return time ; }
void multMat_cpu ( int n , int * arrForce_d , int * arrDistance_d , int * arrAnswer_d ) { for ( int i = 0 ; i < n ; i ++ ) { arrAnswer_d [ i ] = arrForce_d [ i ] * arrDistance_d [ i ] ; } }
void axpy_cpu ( int N , float ALPHA , float * X , int INCX , float * Y , int INCY ) { int i ; for ( i = 0 ; i < N ; ++ i ) Y [ i * INCY ] += ALPHA * X [ i * INCX ] ; }
void castImageTofloat ( float * deviceOutputImageData , unsigned char * ucharImage , int imageWidth , int imageHeight , int channels , int pixelSize ) { int w ; for ( w = 0 ; w < pixelSize ; w ++ ) deviceOutputImageData [ w ] = ( float ) ( ucharImage [ w ] / 255.0 ) ; }
void zero_centroid_vals_cpu ( int k , double * Cx_sum , double * Cy_sum , int * Csize ) { for ( int index = 0 ; index < k ; index ++ ) { Cx_sum [ index ] = 0 ; Cy_sum [ index ] = 0 ; Csize [ index ] = 0 ; } }
void HammingDistanceCPU ( int * c , const int * a , const int * b , long const int * size ) { for ( int i = 0 ; i < * size ; i += 1 ) { if ( a [ i ] != b [ i ] ) * c = * c + 1 ; } }
void castImageToUchar ( float * deviceInputImageData , unsigned char * ucharImage , int imageWidth , int imageHeight , int channels , int pixelSize ) { int w ; for ( w = 0 ; w < pixelSize ; w ++ ) ucharImage [ w ] = ( unsigned char ) ( 255 * deviceInputImageData [ w ] ) ; }
void compareDoubleArrayToThreshold_cpu ( double * d_in , int * d_out , int length , double threshold ) { for ( int idx = 0 ; idx < length ; idx ++ ) { double abs = d_in [ idx ] > 0 ? d_in [ idx ] : - d_in [ idx ] ; d_out [ idx ] = ( abs < threshold ) ; } }
void transpose ( int A [ ] [ 10000 ] , int trans [ ] [ 10000 ] ) { for ( int i = 0 ; i < 10000 ; i ++ ) { for ( int j = 0 ; j < 10000 ; j ++ ) { trans [ i ] [ j ] = A [ j ] [ i ] ; } } }
void ReLU_forward ( float * in , int * mask , int datasize , int training ) { for ( int i = 0 ; i < datasize ; i ++ ) { int keep = in [ i ] > 0 ; if ( training ) mask [ i ] = keep ; if ( ! keep ) in [ i ] = 0 ; } }
void sum_backward ( float * db , float * dout , int r , int c ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int i = 0 ; i < r ; i ++ ) { db [ j ] += dout [ i * c + j ] ; } } }
void clip_cpu ( int N , float ALPHA , float * X , int INCX , float * Y , int INCY ) { int i ; for ( i = 0 ; i < N ; ++ i ) { float val = X [ i * INCX ] ; Y [ i * INCY ] = val > ALPHA ? val : 0 ; } }
void update_x ( double * x , double * a , double * b , int n ) { for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = 2. / 3. * a [ i ] / b [ i ] + 1. / 3. * x [ i ] ; } }
int seqTrans ( float * * h_in , float * * h_out , int x_size , int y_size ) { for ( int y = 0 ; y < y_size ; y ++ ) { for ( int x = 0 ; x < x_size ; x ++ ) { h_out [ x ] [ y ] = h_in [ y ] [ x ] ; } } return 1 ; }
void l2_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float diff = truth [ i ] - pred [ i ] ; error [ i ] = diff * diff ; delta [ i ] = diff ; } }
void flipKernel ( float * array1 , int width ) { for ( int current_index = 0 ; current_index < width * width / 2 ; current_index ++ ) { int replace = ( width - 1 - current_index / width ) * width + current_index % width ; float temp = array1 [ current_index ] ; array1 [ current_index ] = array1 [ replace ] ; array1 [ replace ] = temp ; } }
void get_conf_inds ( const float * mlvl_conf , const float conf_thr , int * conf_inds , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( mlvl_conf [ tid ] >= conf_thr ) { conf_inds [ tid ] = 1 ; } else { conf_inds [ tid ] = -1 ; } } }
void cpuSearchPosShmem1 ( int key , int * gpu_key_arr , int * gpu_pos , int size ) { for ( int globalTx = 0 ; globalTx < size ; globalTx ++ ) { if ( key >= gpu_key_arr [ globalTx ] && key < gpu_key_arr [ globalTx + 1 ] ) { * gpu_pos = globalTx ; } } }
void histogram ( int * hist_out , unsigned char * img_in , int img_size , int nbr_bin ) { int i ; for ( i = 0 ; i < nbr_bin ; i ++ ) { hist_out [ i ] = 0 ; } for ( i = 0 ; i < img_size ; i ++ ) { hist_out [ img_in [ i ] ] ++ ; } }
void mean ( float * A , float * means , int size_row , int size_col ) { for ( int idx = 0 ; idx < size_col ; idx ++ ) { for ( int i = 0 ; i < size_row ; i ++ ) { means [ idx ] += A [ idx * size_row + i ] ; } means [ idx ] = means [ idx ] / size_row ; } }
float reduceCPU ( float * data , int size ) { float sum = data [ 0 ] ; float c = ( float ) 0.0 ; for ( int i = 1 ; i < size ; i ++ ) { float y = data [ i ] - c ; float t = sum + y ; c = ( t - sum ) - y ; sum = t ; } return sum ; }
void pythagoras ( unsigned char * a , unsigned char * b , unsigned char * c , int size ) { int idx ; for ( idx = 0 ; idx < size ; idx ++ ) { float af = ( float ) ( a [ idx ] ) ; float bf = ( float ) ( b [ idx ] ) ; c [ idx ] = ( unsigned char ) sqrtf ( af * af + bf * bf ) ; } }
void avgpool_cpu ( int n , float * input_im , float * output_im ) { for ( int class_index = 0 ; class_index < n ; class_index ++ ) { input_im += 169 * class_index ; float tmp = 0.0f ; for ( int i = 0 ; i < 169 ; i ++ ) { tmp += input_im [ i ] ; } output_im [ class_index ] = tmp / 169.0 ; } }
void weighted_sum_cpu ( float * a , float * b , float * s , int n , float * c ) { int i ; for ( i = 0 ; i < n ; ++ i ) { c [ i ] = s [ i ] * a [ i ] + ( 1 - s [ i ] ) * ( b ? b [ i ] : 0 ) ; } }
void kernel ( float * x , int n ) { int i , j ; for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( j = 0 ; j < 1000 ; j ++ ) { sum += sqrt ( pow ( 3.14159 , i ) ) / ( float ) j ; } x [ i ] = sum ; } }
void MMDSelfComputeWithSum ( float * x_average , int size_x , float * distance_matrix ) { for ( int i = 0 ; i < size_x ; i ++ ) { for ( int j = i ; j < size_x ; j ++ ) { distance_matrix [ i * size_x + j ] = x_average [ i ] * x_average [ j ] ; } } }
void matVecRowSub_cpu ( const double * mat , const double * vec , double * buf , int m , int n ) { for ( int index = 0 ; index < m * n ; index ++ ) { int i = index / n ; int j = index % n ; buf [ i * n + j ] = mat [ i * n + j ] - vec [ j ] ; } }
void transKernel ( float * array1 , float * array2 , int width ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < width ; y ++ ) { int current_index = x * width + y ; int replace = y * width + x ; array2 [ replace ] = array1 [ current_index ] ; } } }
void rowSumSquare_cpu ( const double * mat , double * buf , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < n ; j ++ ) { double a = mat [ i * n + j ] ; sum += a * a ; } buf [ i ] = sum ; } }
void matrixTranspose_cpu ( int * in_mat , int * out_mat , int dim_rows , int dim_cols ) { for ( int i = 0 ; i < dim_rows ; ++ i ) { for ( int j = 0 ; j < dim_cols ; ++ j ) { unsigned int new_pos = j * dim_cols + i ; out_mat [ new_pos ] = in_mat [ i * dim_cols + j ] ; } } }
void analysis ( int D [ ] , int L [ ] , int R [ ] , int N ) { int id ; for ( id = 0 ; id < N ; id ++ ) { int label = L [ id ] ; int ref ; if ( label == id ) { do { label = R [ ref = label ] ; } while ( ref ^ label ) ; R [ id ] = label ; } } }
void Transpose2d ( float * array_transpose , float * array , const int r , const int c ) { int i , j ; for ( i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c ; j ++ ) { array_transpose [ j * r + i ] = array [ i * c + j ] ; } } }
void getMeanImage_cpu ( const double * images , double * meanImage , int imageNum , int pixelNum ) { for ( int col = 0 ; col < pixelNum ; col ++ ) { meanImage [ col ] = 0.0 ; for ( int row = 0 ; row < imageNum ; ++ row ) { meanImage [ col ] += images [ row * pixelNum + col ] ; } meanImage [ col ] /= imageNum ; } }
void Avg ( float * array_avg , float * array , const int r , const int c ) { float sum ; for ( int i = 0 ; i < r ; i ++ ) { sum = 0.0 ; for ( int j = 0 ; j < c ; j ++ ) { sum += array [ i * c + j ] ; } array_avg [ i ] = sum / c ; } }
void smallCorrelation_cpu ( float * L , float * innerSums , int innerSumsLength ) { for ( int u = 0 ; u < innerSumsLength ; u ++ ) { int realIdx = 2 * u ; int imagIdx = realIdx + 1 ; L [ u ] = ( innerSums [ realIdx ] * innerSums [ realIdx ] ) + ( innerSums [ imagIdx ] * innerSums [ imagIdx ] ) ; } }
void cpuDecodeBitstream ( unsigned short * encoded , unsigned short * decoded , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int bit_index = ( i * 2 ) + 2 ; unsigned short curr_bit = encoded [ bit_index ] ; decoded [ bit_index ] = ! encoded [ bit_index - 1 ] ^ curr_bit ; decoded [ bit_index + 1 ] = curr_bit ^ encoded [ bit_index + 1 ] ; } }
void vectorMatrixMult ( long int totalPixels , float * matrix , float * vector , float * out ) { for ( long int i = 0 ; i < totalPixels ; i ++ ) { float sum = 0.0 ; for ( long int j = 0 ; j < totalPixels ; j ++ ) { sum += matrix [ i * totalPixels + j ] * vector [ j ] ; } out [ i ] = sum ; } }
void roundOff ( float * mat , int N , int M ) { int i ; int j ; for ( i = 0 ; i < M ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( mat [ i * N + j ] >= 0 ) mat [ i * N + j ] = ( int ) ( mat [ i * N + j ] + 0.5 ) ; else mat [ i * N + j ] = ( int ) ( mat [ i * N + j ] - 0.5 ) ; } } }
void update_clusters_cpu ( int n , int k , double * Cx , double * Cy , double * Cx_sum , double * Cy_sum , int * Csize ) { for ( int index = 0 ; index < k ; index ++ ) { if ( Csize [ index ] ) { Cx [ index ] = Cx_sum [ index ] / Csize [ index ] ; Cy [ index ] = Cy_sum [ index ] / Csize [ index ] ; } } }
void Gather_cpu ( const int * input , float * output , int input_size , const float * data , int count , int dim , int data_offset ) { int index ; for ( index = 0 ; index < input_size * dim ; index ++ ) { const int input_id = input [ index / dim ] ; const int pos = index % dim ; if ( input_id < count + data_offset && input_id >= data_offset ) { output [ index ] = data [ input_id * dim + pos ] ; } } }
void histogrammPrimitive ( unsigned int * histogrammVector , unsigned char * grayImage , int rows , int columns ) { int column ; int row ; for ( column = 0 ; column < columns ; column ++ ) { for ( row = 0 ; row < rows ; row ++ ) { int offset = ( column ) + ( columns * row ) ; unsigned char grayValue = grayImage [ offset ] ; histogrammVector [ grayValue ] ++ ; } } }
void sumAndScale_cpu ( float * noiseVariance , float * diffMag2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int batchJump = i * 347 ; float temp ; temp = 0 ; for ( int sumIndex = 0 ; sumIndex < 347 ; sumIndex ++ ) temp += diffMag2 [ batchJump + sumIndex ] ; temp = .00161812 * temp ; noiseVariance [ i ] = temp ; } }
void convertInstanceToLabel_Kernel_cpu ( unsigned short * d_outputLabel , const unsigned char * d_inputInstance , const unsigned short * d_instanceToLabel , unsigned int width , unsigned int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { d_outputLabel [ y * width + x ] = d_instanceToLabel [ d_inputInstance [ y * width + x ] ] ; } } }
void downsampleCpu ( float * I , float * Q , unsigned int numDownsampledSamples , float * downsampled_I , float * downsampled_Q , unsigned int factor ) { for ( int sampleIndex = 0 ; sampleIndex < numDownsampledSamples ; sampleIndex ++ ) { unsigned int absoluteIndex = sampleIndex * factor ; downsampled_I [ sampleIndex ] = I [ absoluteIndex ] ; downsampled_Q [ sampleIndex ] = Q [ absoluteIndex ] ; } }
void logistic_x_ent_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float t = truth [ i ] ; float p = pred [ i ] ; error [ i ] = - t * log ( p ) - ( 1 - t ) * log ( 1 - p ) ; delta [ i ] = t - p ; } }
void Argmax ( int * argMax , float * * array , const int r , const int c ) { int idx ; float temp ; for ( int i = 0 ; i < r ; i ++ ) { idx = 0 ; temp = 0.0 ; for ( int j = 0 ; j < c ; j ++ ) { if ( array [ i ] [ j ] > temp ) { temp = array [ i ] [ j ] ; idx = j ; } } argMax [ i ] = idx ; } }
float CEE ( float * x , int * t , int r , int c ) { float temp = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( t [ i * c + j ] == 1 ) { temp += log ( x [ i * c + j ] + 1e-7 ) ; continue ; } } } temp /= - r ; return temp ; }
void check_results_kernel ( unsigned int * g_results0 , unsigned int * g_results1 , int n ) { unsigned int gidx ; unsigned int result0 ; unsigned int result1 ; for ( gidx = 0 ; gidx < n ; gidx ++ ) { result0 = g_results0 [ gidx ] ; result1 = g_results1 [ gidx ] ; if ( result0 != result1 ) { printf ( " % i ▁ ! = ▁ % i ▁ for ▁ % i ▁ \n " , result0 , result1 , gidx ) ; } } }
void matrixMulOnHost ( float * M , float * N , float * P , int width ) { for ( int i = 0 ; i < width ; ++ i ) for ( int j = 0 ; j < width ; ++ j ) { double sum = 0 ; for ( int k = 0 ; k < width ; ++ k ) { double a = M [ i * width + k ] ; double b = N [ k * width + j ] ; sum += a * b ; } P [ i * width + j ] = sum ; } }
void normalize_cpu ( float * x , float * mean , float * variance , int batch , int filters , int spatial ) { int b , f , i ; for ( b = 0 ; b < batch ; ++ b ) { for ( f = 0 ; f < filters ; ++ f ) { for ( i = 0 ; i < spatial ; ++ i ) { int index = b * filters * spatial + f * spatial + i ; x [ index ] = ( x [ index ] - mean [ f ] ) / ( sqrt ( variance [ f ] ) + .000001f ) ; } } } }
void kernel ( int * a , int * b , int * c ) { int idx ; for ( idx = 0 ; idx < 1024 * 1024 ; idx ++ ) { int idx1 = ( idx + 1 ) % 256 ; int idx2 = ( idx + 2 ) % 256 ; float as = ( a [ idx ] + a [ idx1 ] + a [ idx2 ] ) / 3.0f ; float bs = ( b [ idx ] + b [ idx1 ] + b [ idx2 ] ) / 3.0f ; c [ idx ] = ( as + bs ) / 2 ; } }
void kernel ( int * a , int * b , int * c , int size ) { int idx ; for ( idx = 0 ; idx < 1024 * 1024 ; idx ++ ) { int idx1 = ( idx + 1 ) % 256 ; int idx2 = ( idx + 2 ) % 256 ; float as = ( a [ idx ] + a [ idx1 ] + a [ idx2 ] ) / 3.0f ; float bs = ( b [ idx ] + b [ idx1 ] + b [ idx2 ] ) / 3.0f ; c [ idx ] = ( as + bs ) / 2 ; } }
void inter_cpu ( int NX , float * X , int NY , float * Y , int B , float * OUT ) { int i , j ; int index = 0 ; for ( j = 0 ; j < B ; ++ j ) { for ( i = 0 ; i < NX ; ++ i ) { OUT [ index ++ ] = X [ j * NX + i ] ; } for ( i = 0 ; i < NY ; ++ i ) { OUT [ index ++ ] = Y [ j * NY + i ] ; } } }
void manage_adj_matrix ( float * * graph , int n ) { for ( int j = 0 ; j < n ; ++ j ) { float sum = 0.0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += graph [ i ] [ j ] ; } for ( int i = 0 ; i < n ; ++ i ) { if ( sum != 0.0 ) { graph [ i ] [ j ] /= sum ; } else { graph [ i ] [ j ] = ( 1 / ( float ) n ) ; } } } }
void fa_cpu ( const float * q , const float * h , int nq , float * a , float * fa ) { int iq ; for ( iq = 0 ; iq < ( nq - 1 ) ; iq ++ ) { float dq = q [ 1 ] - q [ 0 ] ; a [ iq ] = ( h [ iq + 1 ] * q [ iq + 1 ] - h [ iq ] * q [ iq ] ) / dq ; fa [ iq ] = q [ iq ] * ( a [ iq ] - h [ iq ] ) + 1.0 ; } }
void matrixProduct ( double * matrix_a , double * matrix_b , double * matrix_c , int width , int height , int from , int my_rank ) { int row ; int col ; matrix_c [ row * width + col ] = 0 ; for ( row = 0 ; row < width ; row ++ ) { for ( col = 0 ; col < height ; col ++ ) { for ( int k = 0 ; k < width ; k ++ ) { matrix_c [ row * width + col ] += matrix_a [ ( ( row + from ) * width ) + k ] * matrix_b [ k * width + col ] ; } } } }
void expandBoxes_cpu ( const float * input , float * output , int dims , int clsNum ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { int k = tid / clsNum ; output [ tid * 4 + 0 ] = input [ k * 4 + 0 ] ; output [ tid * 4 + 1 ] = input [ k * 4 + 1 ] ; output [ tid * 4 + 2 ] = input [ k * 4 + 2 ] ; output [ tid * 4 + 3 ] = input [ k * 4 + 3 ] ; } }
void equalization ( float * cdf , float * mincdf , unsigned char * ucharImage , int imageWidth , int imageHeight , int channels , int pixelSize ) { int idx ; for ( idx = 0 ; idx < pixelSize ; idx ++ ) { unsigned char val = ucharImage [ idx ] ; float data = 255 * ( cdf [ val ] - mincdf [ 0 ] ) / ( 1 - mincdf [ 0 ] ) ; if ( data < 0.0f ) data = 0.0f ; else if ( data > 255.0f ) data = 255.0f ; ucharImage [ idx ] = ( unsigned char ) data ; } }
void smooth_l1_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float diff = truth [ i ] - pred [ i ] ; float abs_val = fabs ( diff ) ; if ( abs_val < 1 ) { error [ i ] = diff * diff ; delta [ i ] = diff ; } else { error [ i ] = 2 * abs_val - 1 ; delta [ i ] = ( diff < 0 ) ? 1 : -1 ; } } }
void multiply_matrices ( float * A_Matrix , float * B_Matrix , float * ANS_Matrix , int N ) { int i ; int j ; int k ; float sum ; float m ; float n ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { sum = 0 ; for ( k = 0 ; k < N ; k ++ ) { m = * ( A_Matrix + i * N + k ) ; n = * ( B_Matrix + k * N + j ) ; sum += m * n ; } * ( ANS_Matrix + i * N + j ) = sum ; } } }
void SetToZero_kernel ( float * d_vx , float * d_vy , float * d_vz , int w , int h , int l ) { unsigned int i ; unsigned int j ; for ( i = 0 ; i < w ; i ++ ) { for ( j = 0 ; j < h ; j ++ ) { unsigned int index = j * w + i ; for ( int k = 0 ; k < l ; ++ k , index += w * h ) { d_vx [ index ] = 0 ; d_vy [ index ] = 0 ; d_vz [ index ] = 0 ; } } } }
void solveLower_cpu ( const double * lower , const double * b , double * buf , int dim , int n ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < dim ; i ++ ) { double val = b [ k * dim + i ] ; for ( int j = 0 ; j < i ; j ++ ) { val -= lower [ i * dim + j ] * buf [ k * dim + j ] ; } buf [ k * dim + i ] = val / lower [ i * dim + i ] ; } } }
void deinter_cpu ( int NX , float * X , int NY , float * Y , int B , float * OUT ) { int i , j ; int index = 0 ; for ( j = 0 ; j < B ; ++ j ) { for ( i = 0 ; i < NX ; ++ i ) { if ( X ) X [ j * NX + i ] += OUT [ index ] ; ++ index ; } for ( i = 0 ; i < NY ; ++ i ) { if ( Y ) Y [ j * NY + i ] += OUT [ index ] ; ++ index ; } } }
void binarize_input ( float * input , int n , int size , float * binary ) { int i , s ; for ( s = 0 ; s < size ; ++ s ) { float mean = 0 ; for ( i = 0 ; i < n ; ++ i ) { mean += fabs ( input [ i * size + s ] ) ; } mean = mean / n ; for ( i = 0 ; i < n ; ++ i ) { binary [ i * size + s ] = ( input [ i * size + s ] > 0 ) ? mean : - mean ; } } }
void matrixMultiply_cpu ( float * A , float * B , float * C , int numARows , int numAColumns , int numBRows , int numBColumns ) { int numCRows = numARows ; int numCColumns = numBColumns ; for ( int row = 0 ; row < numCRows ; row ++ ) { for ( int col = 0 ; col < numCColumns ; col ++ ) { float sum = 0 ; for ( int k = 0 ; k < numBRows ; k ++ ) { sum += A [ row * numAColumns + k ] * B [ k * numBColumns + col ] ; } C [ row * numCColumns + col ] = sum ; } } }
void backward_avgpool_layer ( int batch , int c , int w , int h , float * delta ) { int b , i , k ; for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < c ; ++ k ) { int out_index = k + b * c ; for ( i = 0 ; i < h * w ; ++ i ) { int in_index = i + h * w * ( k + b * c ) ; delta [ in_index ] += delta [ out_index ] / ( h * w ) ; } } } }
void mean_cpu ( float * x , int batch , int filters , int spatial , float * mean ) { float scale = 1. / ( batch * spatial ) ; int i , j , k ; for ( i = 0 ; i < filters ; ++ i ) { mean [ i ] = 0 ; for ( j = 0 ; j < batch ; ++ j ) { for ( k = 0 ; k < spatial ; ++ k ) { int index = j * filters * spatial + i * spatial + k ; mean [ i ] += x [ index ] ; } } mean [ i ] *= scale ; } }
void boxesScale_cpu ( const float * input , float * output , int dims , float scale0 , float scale1 , float scale2 , float scale3 ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { output [ tid * 4 ] = input [ tid * 4 ] / scale0 ; output [ tid * 4 + 1 ] = input [ tid * 4 + 1 ] / scale1 ; output [ tid * 4 + 2 ] = input [ tid * 4 + 2 ] / scale2 ; output [ tid * 4 + 3 ] = input [ tid * 4 + 3 ] / scale3 ; } }
void mat_mul_seq ( int * m_A , int * m_B , int * m_C , int A_rows , int A_cols , int B_rows , int B_cols ) { int sum ; for ( int i = 0 ; i < A_rows ; i ++ ) { for ( int j = 0 ; j < B_cols ; j ++ ) { sum = 0 ; for ( int k = 0 ; k < A_cols ; k ++ ) { sum += m_A [ i * A_cols + k ] * m_B [ k * B_cols + j ] ; } m_C [ i * B_cols + j ] = sum ; } } }
void create_p_vect ( float * node_info1 , float * node_info2 , float * p , int n_nodes_1 , int n_nodes_2 ) { int tx ; int ty ; float cutoff = 0.5 ; for ( tx = 0 ; tx < n_nodes_1 ; tx ++ ) { for ( ty = 0 ; ty < n_nodes_2 ; ty ++ ) { int ind = tx * n_nodes_2 + ty ; if ( ( node_info1 [ tx ] < cutoff ) && ( node_info2 [ ty ] < cutoff ) ) p [ ind ] = 0 ; else p [ ind ] = node_info1 [ tx ] * node_info2 [ ty ] ; } } }
void calcbidvalues ( int n , int * src2tgt , float * adj , float * prices , unsigned short * complete , float * values , float * bids ) { for ( int idx = 0 ; idx < n * n ; idx ++ ) { int i = idx / n ; int j = idx - i * n ; bids [ i * n + j ] = -1 ; if ( src2tgt [ i ] != -1 ) { continue ; } complete [ 0 ] = 0 ; values [ i * n + j ] = - adj [ i * n + j ] - prices [ j ] ; } }
void convolutionRowCPU ( float * h_Dst , float * h_Src , float * h_Filter , int imageW , int imageH , int filterR ) { int x , y , k ; for ( y = 0 ; y < imageH ; y ++ ) { for ( x = 0 ; x < imageW ; x ++ ) { float sum = 0 ; for ( k = - filterR ; k <= filterR ; k ++ ) { int d = x + k ; if ( d >= 0 && d < imageW ) { sum += h_Src [ y * imageW + d ] * h_Filter [ filterR - k ] ; } h_Dst [ y * imageW + x ] = sum ; } } } }
void castImageToGrayScale ( unsigned char * ucharImage , unsigned char * grayImage , int imageWidth , int imageHeight , int channels ) { int w ; int h ; for ( w = 0 ; w < imageWidth ; w ++ ) { for ( h = 0 ; h < imageHeight ; h ++ ) { int idx = imageWidth * h + w ; unsigned char r = ucharImage [ idx * channels ] ; unsigned char g = ucharImage [ idx * channels + 1 ] ; unsigned char b = ucharImage [ idx * channels + 2 ] ; grayImage [ idx ] = ( unsigned char ) ( 0.21f * r + 0.71f * g + 0.07f * b ) ; } } }
void CPU_array_rowKernel ( double * input , double * output , int length ) { int xCuda ; int yCuda ; for ( xCuda = 0 ; xCuda < length ; xCuda ++ ) { for ( yCuda = 0 ; yCuda < length ; yCuda ++ ) { int idx = yCuda * length + xCuda ; if ( xCuda == 0 || xCuda == length - 1 ) { output [ idx ] = 0 ; } else { output [ idx ] = input [ idx ] ; output [ idx ] += xCuda == 0 ? 0 : input [ idx - 1 ] ; output [ idx ] += xCuda == length - 1 ? 0 : input [ idx + 1 ] ; } } } }
void waterElevationToDepth_cpu ( const int nx_ , const int ny_ , float * h_ptr_ , int h_pitch_ , float * Bm_ptr_ , int Bm_pitch_ ) { for ( int ti = 0 ; ti < nx_ ; ti ++ ) { for ( int tj = 0 ; tj < ny_ ; tj ++ ) { float * h_row = ( float * ) ( ( char * ) h_ptr_ + h_pitch_ * tj ) ; float * Bm_row = ( float * ) ( ( char * ) Bm_ptr_ + Bm_pitch_ * tj ) ; h_row [ ti ] -= Bm_row [ ti ] ; } } }
void softmax ( float * x , int r , int c ) { float temp1 , temp2 ; for ( int i = 0 ; i < r ; i ++ ) { temp1 = 0. ; temp2 = 0. ; for ( int j = 0 ; j < c ; j ++ ) { temp1 = max ( x [ i * c + j ] , temp1 ) ; } for ( int j = 0 ; j < c ; j ++ ) { x [ i * c + j ] = expf ( x [ i * c + j ] - temp1 ) ; temp2 += x [ i * c + j ] ; } for ( int j = 0 ; j < c ; j ++ ) x [ i * c + j ] /= temp2 ; } }
void cuda_Adam_step_kernel ( float * grad , float * data , float * m , float * v , short decay , float weight_decay , float beta1 , float beta2 , float eps , float step_size , int varsize ) { for ( int i = 0 ; i < varsize ; i ++ ) { float g = grad [ i ] ; if ( decay ) g += weight_decay * data [ i ] ; m [ i ] = beta1 * m [ i ] + ( 1.0 - beta1 ) * g ; v [ i ] = beta2 * v [ i ] + ( 1.0 - beta2 ) * g * g ; data [ i ] -= step_size * m [ i ] / ( sqrt ( v [ i ] ) + eps ) ; } }
void flatten ( float * x , int size , int layers , int batch , int forward ) { float * swap = calloc ( size * layers * batch , sizeof ( float ) ) ; int i , c , b ; for ( b = 0 ; b < batch ; ++ b ) { for ( c = 0 ; c < layers ; ++ c ) { for ( i = 0 ; i < size ; ++ i ) { int i1 = b * layers * size + c * size + i ; int i2 = b * layers * size + i * layers + c ; if ( forward ) swap [ i2 ] = x [ i1 ] ; else swap [ i1 ] = x [ i2 ] ; } } } memcpy ( x , swap , size * layers * batch * sizeof ( float ) ) ; free ( swap ) ; }
void Softmax ( float * x , const int r , const int c ) { float temp1 , temp2 ; for ( int i = 0 ; i < r ; i ++ ) { temp1 = 0. ; temp2 = 0. ; for ( int j = 0 ; j < c ; j ++ ) { temp1 = max ( x [ i * c + j ] , temp1 ) ; } for ( int j = 0 ; j < c ; j ++ ) { x [ i * c + j ] = expf ( x [ i * c + j ] - temp1 ) ; temp2 += x [ i * c + j ] ; } for ( int j = 0 ; j < c ; j ++ ) x [ i * c + j ] /= temp2 ; } }
void deInterleave_cpu2 ( float * d_X_out , float * d_Y_out , char * d_XY_in , int pitch_out , int pitch_in , int width , int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { float * data = ( float * ) ( d_XY_in + y * pitch_in ) + 2 * x ; * ( ( float * ) ( ( char * ) d_X_out + y * pitch_out ) + x ) = data [ 0 ] ; * ( ( float * ) ( ( char * ) d_Y_out + y * pitch_out ) + x ) = data [ 1 ] ; } } }
void cpu_laplace_filter ( float * Img , float * laplace , float _dz , float _dx , int npml , int nnz , int nnx ) { for ( int i1 = npml ; i1 < nnz - npml ; i1 ++ ) { for ( int i2 = npml ; i2 < nnx - npml ; i2 ++ ) { int id = i1 + i2 * nnz ; float diff1 = 0.0f ; float diff2 = 0.0f ; diff1 = Img [ id + 1 ] - 2.0 * Img [ id ] + Img [ id - 1 ] ; diff2 = Img [ id + nnz ] - 2.0 * Img [ id ] + Img [ id - nnz ] ; laplace [ id ] = _dz * _dz * diff1 + _dx * _dx * diff2 ; } } }
void distanceMatFinal ( long int totalPixels , int availablePixels , int outPixelOffset , float * distMat ) { for ( long int i = 0 ; i < availablePixels ; i ++ ) { float sum = 0.0 ; float max = 0.0 ; for ( long int j = 0 ; j < totalPixels ; j ++ ) { float element = distMat [ i * totalPixels + j ] ; if ( element > max ) max = element ; sum += element ; } sum += max ; for ( long int j = 0 ; j < totalPixels ; j ++ ) { if ( ( i + outPixelOffset ) == j ) distMat [ i * totalPixels + j ] = max / sum ; else distMat [ i * totalPixels + j ] /= sum ; } } }
void permuteData2_cpu ( const float * input , float * output , int num , int devideNum , int featureSize , int priorNum , int batchSize ) { for ( int tid = 0 ; tid < num ; tid ++ ) { int numPerbatch = num * devideNum * priorNum ; for ( int s = 0 ; s < batchSize ; s ++ ) { for ( int i = 0 ; i < priorNum ; i ++ ) { for ( int j = 0 ; j < devideNum ; j ++ ) { output [ s * numPerbatch + tid * priorNum * devideNum + i * devideNum + j ] = input [ s * numPerbatch + ( i * devideNum * featureSize ) + ( j * featureSize ) + tid ] ; } } } } }
void permuteDataTorch_cpu ( const float * input , float * output , int num , int devideNum , int featureSize , int priorNum , int batchSize ) { for ( int tid = 0 ; tid < num ; tid ++ ) { int numPerbatch = num * devideNum * priorNum ; for ( int s = 0 ; s < batchSize ; s ++ ) { for ( int i = 0 ; i < priorNum ; i ++ ) { for ( int j = 0 ; j < devideNum ; j ++ ) { output [ s * numPerbatch + tid * priorNum * devideNum + i * devideNum + j ] = input [ s * numPerbatch + ( i * devideNum * featureSize ) + ( j * featureSize ) + tid ] ; } } } } }
void conv1x1_cpu ( int input_channels , int input_size , int n , float * input_im , float * filter_weight , float * filter_bias , float * output_im ) { for ( int filter_index = 0 ; filter_index < n ; filter_index ++ ) { filter_weight += filter_index * input_channels ; float bias = filter_bias [ filter_index ] ; output_im += filter_index * input_size * input_size ; for ( int i = 0 ; i < input_size ; i ++ ) { for ( int j = 0 ; j < input_size ; j ++ ) { float tmp = bias ; for ( int k = 0 ; k < input_channels ; k ++ ) { tmp += input_im [ k * input_size * input_size + i * input_size + j ] * filter_weight [ k ] ; } output_im [ i * input_size + j ] = ( tmp > 0.0 ) ? tmp : 0.0 ; } } } }
void Softmax_seg ( float * x , const int size_category , const int size_spatial_feature_map ) { int c = size_category ; int size = size_spatial_feature_map ; float temp1 , temp2 ; for ( int i = 0 ; i < size ; i ++ ) { temp1 = 0. ; temp2 = 0. ; for ( int j = 0 ; j < c ; j ++ ) { temp1 = max ( x [ j * size + i ] , temp1 ) ; } for ( int j = 0 ; j < c ; j ++ ) { x [ j * size + i ] = expf ( x [ j * size + i ] - temp1 ) ; temp2 += x [ j * size + i ] ; } for ( int j = 0 ; j < c ; j ++ ) x [ j * size + i ] /= temp2 ; } }
void pad_input ( float * f_in , float * f_out , int H , int W , int D , int pad ) { int col ; int row ; int dep ; int new_H = H + 2 * pad ; int new_W = W + 2 * pad ; for ( col = 0 ; col < new_H ; col ++ ) { for ( row = 0 ; row < new_W ; row ++ ) { for ( dep = 0 ; dep < D ; dep ++ ) { int i = dep * new_H * new_W + col * new_W + row ; int j = dep * H * W + ( col - pad ) * W + ( row - pad ) ; if ( ( col < pad || col > H + pad - 1 ) || ( row < pad || row > W + pad - 1 ) ) f_out [ i ] = 0 ; else f_out [ i ] = f_in [ j ] ; } } } }
void waterDepthToElevation_cpu ( const int nx_ , const int ny_ , float * w_ptr_ , int w_pitch_ , float * h_ptr_ , int h_pitch_ , float * Bm_ptr_ , int Bm_pitch_ ) { for ( int ti = 0 ; ti < nx_ ; ti ++ ) { for ( int tj = 0 ; tj < ny_ ; tj ++ ) { float * h_row = ( float * ) ( ( char * ) h_ptr_ + h_pitch_ * tj ) ; float * Bm_row = ( float * ) ( ( char * ) Bm_ptr_ + Bm_pitch_ * tj ) ; float * w_row = ( float * ) ( ( char * ) w_ptr_ + w_pitch_ * tj ) ; w_row [ ti ] = h_row [ ti ] + Bm_row [ ti ] ; } } }
void invalidateFlow_cpu ( float * modFlowX , float * modFlowY , const float * constFlowX , const float * constFlowY , int width , int height , float cons_thres ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { int ind = y * width + x ; float mFX = modFlowX [ ind ] ; float mFY = modFlowY [ ind ] ; float cFX = constFlowX [ ind ] ; float cFY = constFlowY [ ind ] ; float err = ( mFX - cFX ) * ( mFX - cFX ) + ( mFY - cFY ) * ( mFY - cFY ) ; if ( err > cons_thres ) { mFX = 0 ; mFY = 0 ; } modFlowX [ ind ] = mFX ; modFlowY [ ind ] = mFY ; } } }
void cpuRunComplexFilter ( float * I , float * Q , int samplesLength , float * hr , float * hi , int filterLength , float * filtered_I , float * filtered_Q , int convLength ) { for ( int sampleIndex = 0 ; sampleIndex < convLength ; sampleIndex ++ ) { int index ; float sumI , sumQ ; sumI = 0 ; sumQ = 0 ; for ( int j = sampleIndex - filterLength + 1 ; j <= sampleIndex ; j ++ ) { index = sampleIndex - j ; if ( ( j < samplesLength ) && ( j >= 0 ) ) { sumI += ( I [ j ] * hr [ index ] ) - ( Q [ j ] * hi [ index ] ) ; sumQ += ( I [ j ] * hi [ index ] ) + ( Q [ j ] * hr [ index ] ) ; } } filtered_I [ sampleIndex ] = sumI ; filtered_Q [ sampleIndex ] = sumQ ; } }
void opL21_cpu ( float * vec , float * vec1 , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long long i = z * rows * cols + y * cols + x ; unsigned long long j = z * rows * cols + x ; unsigned long size2d = cols ; unsigned long size3d = depth * rows * cols + rows * cols + cols ; if ( i + cols + 1 >= size3d ) return ; vec [ i + cols ] = 0.25 * ( vec1 [ i + 1 ] + vec1 [ i ] + vec1 [ i + cols + 1 ] + vec1 [ i + cols ] ) ; if ( j + 1 >= size2d ) return ; vec [ j ] = ( vec1 [ j ] + vec1 [ j + 1 ] ) / 4 ; } } } }
void reorg_cpu ( float * x , int w , int h , int c , int batch , int stride , int forward , float * out ) { int b , i , j , k ; int out_c = c / ( stride * stride ) ; for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < c ; ++ k ) { for ( j = 0 ; j < h ; ++ j ) { for ( i = 0 ; i < w ; ++ i ) { int in_index = i + w * ( j + h * ( k + c * b ) ) ; int c2 = k % out_c ; int offset = k / out_c ; int w2 = i * stride + offset % stride ; int h2 = j * stride + offset / stride ; int out_index = w2 + w * stride * ( h2 + h * stride * ( c2 + out_c * b ) ) ; if ( forward ) out [ out_index ] = x [ in_index ] ; else out [ in_index ] = x [ out_index ] ; } } } } }
long int maxValExtractArray ( float * normM_aux , long int * b_pos , long int b_pos_size ) { float max_val = -1 ; long int pos = -1 ; long int i ; for ( i = 0 ; i < b_pos_size ; i ++ ) { if ( normM_aux [ b_pos [ i ] ] > max_val ) { max_val = normM_aux [ b_pos [ i ] ] ; pos = i ; } } return pos ; }
void returnResult_cpu ( const float * box , const float * score , const int * label , float * box_out , float * score_out , int * label_out , float score_thr , const int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( score [ tid ] < score_thr ) { score_out [ tid ] = 0 ; box_out [ tid * 4 + 0 ] = -1 ; box_out [ tid * 4 + 1 ] = -1 ; box_out [ tid * 4 + 2 ] = -1 ; box_out [ tid * 4 + 3 ] = -1 ; label_out [ tid ] = -1 ; } else { score_out [ tid ] = score [ tid ] ; box_out [ tid * 4 + 0 ] = box [ tid * 4 + 0 ] ; box_out [ tid * 4 + 1 ] = box [ tid * 4 + 1 ] ; box_out [ tid * 4 + 2 ] = box [ tid * 4 + 2 ] ; box_out [ tid * 4 + 3 ] = box [ tid * 4 + 3 ] ; label_out [ tid ] = label [ tid ] ; } } }
void * RyT ( float * R , float * T , float * P , float * Q , int start , int end ) { for ( int i = start ; i < end ; i ++ ) { Q [ 0 + i * 3 ] = R [ 0 + 0 * 3 ] * P [ 0 + i * 3 ] + R [ 0 + 1 * 3 ] * P [ 1 + i * 3 ] + R [ 0 + 2 * 3 ] * P [ 2 + i * 3 ] + T [ 0 ] ; Q [ 1 + i * 3 ] = R [ 1 + 0 * 3 ] * P [ 0 + i * 3 ] + R [ 1 + 1 * 3 ] * P [ 1 + i * 3 ] + R [ 1 + 2 * 3 ] * P [ 2 + i * 3 ] + T [ 1 ] ; Q [ 2 + i * 3 ] = R [ 2 + 0 * 3 ] * P [ 0 + i * 3 ] + R [ 2 + 1 * 3 ] * P [ 1 + i * 3 ] + R [ 2 + 2 * 3 ] * P [ 2 + i * 3 ] + T [ 2 ] ; } return ( void * ) 0 ; }
void primal_descent ( float * y1 , float * y2 , float * xbar , float sigma , int w , int h , int nc ) { for ( int x = 0 ; x < w ; x ++ ) { for ( int y = 0 ; y < h ; y ++ ) { int i ; float x1 , x2 , val , norm ; for ( int z = 0 ; z < nc ; z ++ ) { i = x + w * y + w * h * z ; val = xbar [ i ] ; x1 = ( x + 1 < w ) ? ( xbar [ ( x + 1 ) + w * y + w * h * z ] - val ) : 0.f ; x2 = ( y + 1 < h ) ? ( xbar [ x + w * ( y + 1 ) + w * h * z ] - val ) : 0.f ; x1 = y1 [ i ] + sigma * x1 ; x2 = y2 [ i ] + sigma * x2 ; norm = sqrtf ( x1 * x1 + x2 * x2 ) ; y1 [ i ] = x1 / fmax ( 1.f , norm ) ; y2 [ i ] = x2 / fmax ( 1.f , norm ) ; } } } }
void fractal_cpu ( const int width , const int frames , unsigned char * const pic ) { for ( int i = 0 ; i < width * width * frames ; i ++ ) { const double Delta = 0.00304 ; const double xMid = -0.055846456 ; const double yMid = -0.668311119 ; const int frame = i / ( width * width ) ; double delta = Delta * pow ( 0.975 , frame ) ; const int col = i % width ; const double xMin = xMid - delta ; const double yMin = yMid - delta ; const double dw = 2.0 * delta / width ; const int row = ( i / width ) % width ; const double cy = yMin + row * dw ; const double cx = xMin + col * dw ; double x = cx ; double y = cy ; double x2 , y2 ; int count = 256 ; do { x2 = x * x ; y2 = y * y ; y = 2.0 * x * y + cy ; x = x2 - y2 + cx ; count -- ; } while ( ( count > 0 ) && ( ( x2 + y2 ) <= 5.0 ) ) ; pic [ frame * width * width + row * width + col ] = ( unsigned char ) count ; } }
void Ring_cpu_kernel ( float * A , float * BP , int * corrAB , float * M , int ring , int c , int h , int w ) { int ringSize = 2 * ring + 1 ; int ringPatch = ringSize * ringSize ; int size = h * w ; #pragma omp parallel for ENDCOM for ( int y1 = 0 ; y1 < h ; y1 ++ ) for ( int x1 = 0 ; x1 < w ; x1 ++ ) { int id = y1 * w + x1 ; int x2 = corrAB [ 2 * id + 0 ] ; int y2 = corrAB [ 2 * id + 1 ] ; for ( int dx = - ring ; dx <= ring ; dx ++ ) for ( int dy = - ring ; dy <= ring ; dy ++ ) { int pIdx = ( dy + ring ) * ringSize + ( dx + ring ) ; int _x2 = x2 + dx , _y2 = y2 + dy ; if ( _x2 >= 0 && _x2 < w && _y2 >= 0 && _y2 < h ) { for ( int dc = 0 ; dc < c ; dc ++ ) { M [ ( dc * size + y1 * w ) * ringPatch + pIdx * w + x1 ] = BP [ dc * size + _y2 * w + _x2 ] ; } } } } return ; }
void convolutionCPU ( float * host_outputMatrix , float * host_inputMatrix , float * host_filter , int imageRows , int imageColumns , int filterSize ) { #pragma omp parallel ENDCOM for ( int eachRowOfImage = 0 ; eachRowOfImage < ( int ) imageRows ; ++ eachRowOfImage ) { for ( int eachColumnOfImage = 0 ; eachColumnOfImage < ( int ) imageColumns ; ++ eachColumnOfImage ) { float convolvedValue = 0.f ; for ( int eachRowOfFilter = - filterSize / 2 ; eachRowOfFilter <= filterSize / 2 ; ++ eachRowOfFilter ) { for ( int eachColumnOfFilter = - filterSize / 2 ; eachColumnOfFilter <= filterSize / 2 ; ++ eachColumnOfFilter ) { int imageRow = eachRowOfImage + eachRowOfFilter ; int imageColumn = eachColumnOfImage + eachColumnOfFilter ; float pixelValue = ( imageRow >= 0 && imageRow < imageRows && imageColumn >= 0 && imageColumn < imageColumns ) ? host_inputMatrix [ imageRow * imageColumns + imageColumn ] : 0.f ; float filterValue = host_filter [ ( eachRowOfFilter + filterSize / 2 ) * filterSize + eachColumnOfFilter + filterSize / 2 ] ; convolvedValue += pixelValue * filterValue ; } } host_outputMatrix [ eachRowOfImage * imageColumns + eachColumnOfImage ] = convolvedValue ; } } }
void opLadj1_cpu ( float * vec , float * vec1 , float * vec2 , float * vec3 , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long long i = z * rows * cols + y * cols + x ; unsigned long long j = z * rows * cols + x ; unsigned long size2d = cols ; unsigned long size3d = depth * rows * cols + rows * cols + cols ; if ( i + cols + 1 >= size3d ) return ; vec [ i + cols ] = vec1 [ i + cols ] + 0.25 * ( vec2 [ i + cols ] + vec2 [ i ] + vec2 [ i + cols + 1 ] + vec2 [ i + 1 ] ) + 0.5 * ( vec3 [ i + cols ] + vec3 [ i + cols + 1 ] ) ; if ( j + 1 >= size2d ) return ; vec [ j ] = vec1 [ j ] + ( vec2 [ j ] + vec2 [ j + 1 ] ) / 4 + ( vec3 [ j ] + vec3 [ j + 1 ] ) / 2 ; } } } }
void dual_ascent ( float * xn , float * xbar , float * y1 , float * y2 , float * img , float tau , float lambda , float theta , int w , int h , int nc ) { for ( int x = 0 ; x < w ; x ++ ) { for ( int y = 0 ; y < h ; y ++ ) { int i ; float d1 , d2 , val ; for ( int z = 0 ; z < nc ; z ++ ) { i = x + w * y + w * h * z ; d1 = ( x + 1 < w ? y1 [ i ] : 0.f ) - ( x > 0 ? y1 [ ( x - 1 ) + w * y + w * h * z ] : 0.f ) ; d2 = ( y + 1 < h ? y2 [ i ] : 0.f ) - ( y > 0 ? y2 [ x + w * ( y - 1 ) + w * h * z ] : 0.f ) ; val = xn [ i ] ; xn [ i ] = ( ( val + tau * ( d1 + d2 ) ) + tau * lambda * img [ i ] ) / ( 1.f + tau * lambda ) ; xbar [ i ] = xn [ i ] + theta * ( xn [ i ] - val ) ; } } } }
void convoluteCPU ( float * dData , float * hData , int height , int width , float * mask , int masksize ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { int S = ( masksize - 1 ) / 2 ; float sum = 0 ; int pixPos = row * width + col ; dData [ pixPos ] = 0.0 ; for ( int maskrow = - S ; maskrow <= S ; maskrow ++ ) { for ( int maskcol = - S ; maskcol <= S ; maskcol ++ ) { int pixP = ( row + maskrow ) * width + ( col + maskcol ) ; int maskP = ( maskrow + S ) * masksize + ( maskcol + S ) ; if ( pixP < height * width && pixP > 0 && maskP < masksize * masksize ) { sum += mask [ maskP ] * hData [ pixP ] ; } } } dData [ pixPos ] = sum ; if ( dData [ pixPos ] < 0 ) { dData [ pixPos ] = 0 ; } else if ( dData [ pixPos ] > 1 ) { dData [ pixPos ] = 1 ; } } } }
void opLadj2_cpu ( float * vec , float * vec1 , float * vec2 , float * vec3 , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long long i = z * rows * cols + y * cols + x ; unsigned long long j = z * rows * cols + y * cols ; unsigned long size2d = z * rows * cols + cols * rows ; unsigned long size3d = depth * rows * cols + rows * cols + cols ; if ( i + cols + 1 >= size3d ) return ; vec [ i + 1 ] = vec1 [ i + 1 ] + 0.25 * ( vec2 [ i + 1 ] + vec2 [ i ] + vec2 [ i + cols + 1 ] + vec2 [ i + cols ] ) + 0.5 * ( vec3 [ i + 1 ] + vec3 [ i + cols + 1 ] ) ; if ( j + cols >= size2d ) return ; vec [ j ] = vec1 [ j ] + ( vec2 [ j ] + vec2 [ j + cols ] ) / 4 + ( vec3 [ j ] + vec3 [ j + cols ] ) / 2 ; } } } }
void CrossEntropyLoss_forward ( float * logits_data , float * logits_grad , float * loss , int * truth , int training , int num_classes , int size , int grad_size ) { float total_loss = 0 ; int count = 0 ; for ( int i = 0 ; i < size / num_classes ; i ++ ) { if ( truth [ i ] < 0 ) continue ; count ++ ; float * logit = & logits_data [ i * num_classes ] ; float max_logit = -1e30 , sum_exp = 0 ; for ( int j = 0 ; j < num_classes ; j ++ ) max_logit = fmax ( max_logit , logit [ j ] ) ; for ( int j = 0 ; j < num_classes ; j ++ ) { logit [ j ] -= max_logit ; sum_exp += expf ( logit [ j ] ) ; } total_loss += logf ( sum_exp ) - logit [ truth [ i ] ] ; if ( training ) { for ( int j = 0 ; j < num_classes ; j ++ ) { float prob = expf ( logit [ j ] ) / sum_exp ; logits_grad [ i * num_classes + j ] = prob ; } logits_grad [ i * num_classes + truth [ i ] ] -= 1.0 ; } } * loss = total_loss / count ; if ( training ) { for ( int i = 0 ; i < grad_size ; i ++ ) logits_grad [ i ] /= count ; } }
void insert_sort ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; while ( ( a [ j ] < a [ i ] ) && ( j < i ) ) { j ++ ; } if ( i != j ) { int temp = a [ i ] ; for ( int k = i ; k > j ; k -- ) { a [ k ] = a [ k - 1 ] ; } a [ j ] = temp ; } } }
void conv2_cpu ( float * A , float * kernel , int inputSize , int depth , int kernelSize , int stride , int pad , float * B , int outputSize ) { for ( int i = 0 ; i < outputSize ; i ++ ) { for ( int j = 0 ; j < outputSize ; j ++ ) { int Ai = i * stride ; int Aj = j * stride ; int startk = ( pad - Ai ) < 0 ? 0 : pad - Ai ; int endk = kernelSize < ( inputSize + pad - Ai ) ? kernelSize : ( inputSize + pad - Ai ) ; int startl = ( pad - Aj ) < 0 ? 0 : pad - Aj ; int endl = kernelSize < ( inputSize + pad - Aj ) ? kernelSize : ( inputSize + pad - Aj ) ; float sum = 0 ; for ( int d = 0 ; d < depth ; d ++ ) { for ( int k = startk ; k < endk ; k ++ ) { for ( int l = startl ; l < endl ; l ++ ) { sum += A [ d * inputSize * inputSize + ( Ai + k - pad ) * inputSize + Aj + l - pad ] * kernel [ d * kernelSize * kernelSize + k * kernelSize + l ] ; } } B [ d * outputSize * outputSize + i * outputSize + j ] = sum ; } B [ i * outputSize + j ] = sum ; } } }
void get_positive_data_cpu ( const float * all_box , const float * all_scores , const float * all_conf , const int * conf_inds , float * positive_box , float * positive_scores , float * positive_conf , int dims , int clsNum ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( conf_inds [ tid ] != ( -1 ) ) { positive_box [ tid * 4 + 0 ] = all_box [ tid * 4 + 0 ] ; positive_box [ tid * 4 + 1 ] = all_box [ tid * 4 + 1 ] ; positive_box [ tid * 4 + 2 ] = all_box [ tid * 4 + 2 ] ; positive_box [ tid * 4 + 3 ] = all_box [ tid * 4 + 3 ] ; for ( int i = 0 ; i < clsNum ; i ++ ) { positive_scores [ tid * clsNum + i ] = all_scores [ tid * clsNum + i ] ; } positive_conf [ tid ] = all_conf [ tid ] ; } else { positive_box [ tid * 4 + 0 ] = 0 ; positive_box [ tid * 4 + 1 ] = 0 ; positive_box [ tid * 4 + 2 ] = 0 ; positive_box [ tid * 4 + 3 ] = 0 ; for ( int i = 0 ; i < clsNum ; i ++ ) { positive_scores [ tid * clsNum + i ] = ( -1 ) ; } positive_conf [ tid ] = ( -1 ) ; } } }
void cpuChoiLee ( float * xi , float * xq , float * sr , float * si , int N , float * L ) { for ( int u = 0 ; u < N ; u ++ ) { float uSum = 0 ; float r_i , r_q , rconj_i , rconj_q ; float s_i , s_q , sconj_i , sconj_q ; float rsum_i , rsum_q , ssum_i , ssum_q ; float ksum_i , ksum_q ; for ( int i = 0 ; i < N ; i ++ ) { ksum_i = 0 ; ksum_q = 0 ; for ( int k = 0 ; k < N - i ; k ++ ) { r_i = xi [ u + k + i ] ; r_q = xq [ u + k + i ] ; rconj_i = xi [ u + k ] ; rconj_q = xq [ u + k ] * ( -1 ) ; s_i = sr [ k ] ; s_q = si [ k ] ; sconj_i = sr [ k + i ] ; sconj_q = si [ k + i ] * ( -1 ) ; rsum_i = ( r_i * rconj_i ) - ( r_q * rconj_q ) ; rsum_q = ( r_i * rconj_q ) + ( r_q * rconj_i ) ; ssum_i = ( s_i * sconj_i ) - ( s_q * sconj_q ) ; ssum_q = ( s_i * sconj_q ) + ( s_q * sconj_i ) ; ksum_i += ( rsum_i * ssum_i ) - ( rsum_q * ssum_q ) ; ksum_q += ( rsum_i * ssum_q ) + ( rsum_q * ssum_i ) ; } uSum += sqrt ( ( ksum_i * ksum_i ) + ( ksum_q * ksum_q ) ) ; } L [ u ] = uSum ; } }
void calculateOuterSumsNew_cpu ( float * innerSums , float * L , int uLength ) { for ( int u = 0 ; u < uLength ; u ++ ) { float real , imag , u_sum ; int realIdx = 2 * u ; int imagIdx = realIdx + 1 ; # 16 " / lustre / S / wenyuanbo / Workspace / gitlab / CodeGen / cpp _ cuda _ test _ files / process _ test _ data / test _ data _ 12<unk> 11273 - Kernels . cu - calculateOuterSumsNew . c " real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum = ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; realIdx += 64 ; imagIdx += 64 ; real = innerSums [ realIdx ] ; imag = innerSums [ imagIdx ] ; u_sum += ( real * real ) + ( imag * imag ) ; L [ u ] = u_sum ; } }
void nlf_right_forward_cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top_data ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int col = 0 ; col < width ; col ++ ) { for ( int row = 0 ; row < height ; row ++ ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row ; c = col - 1 ; shift = 1 * step + row * width + col ; if ( c >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col - 1 ; shift = 2 * step + row * width + col ; if ( c >= 0 && r >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col - 1 ; shift = 3 * step + row * width + col ; if ( c >= 0 && r < height ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col ; shift = 4 * step + row * width + col ; if ( r >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; top_data [ base + row * width + col ] = temp ; } } } }
void nlf_filter_right_backward_cpu ( const int n , const float * bottom_data , const float * top_data , const float * temp_diff , const int channel , const int height , const int width , const int wsize , float * filters_diff ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index / step * step * channel + index % step ; int fbase = index / step * step * wsize + index % step ; int row = index % step / width ; int col = index % step % width ; for ( int i = 0 ; i < channel ; i ++ ) { filters_diff [ fbase ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col - 1 >= 0 ) filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * top_data [ base - 1 + i * step ] ; else filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col - 1 >= 0 && row - 1 >= 0 ) filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * top_data [ base - width - 1 + i * step ] ; else filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col - 1 >= 0 && row + 1 < height ) filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * top_data [ base + width - 1 + i * step ] ; else filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row - 1 >= 0 ) filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * top_data [ base - width + i * step ] ; else filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; } } }
void nlf_filter_up_backward_cpu ( const int n , const float * bottom_data , const float * top_data , const float * temp_diff , const int channel , const int height , const int width , const int wsize , float * filters_diff ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index / step * step * channel + index % step ; int fbase = index / step * step * wsize + index % step ; int row = index % step / width ; int col = index % step % width ; for ( int i = 0 ; i < channel ; i ++ ) { filters_diff [ fbase ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row + 1 < height ) filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * top_data [ base + width + i * step ] ; else filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row + 1 < height && col - 1 >= 0 ) filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * top_data [ base + width - 1 + i * step ] ; else filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row + 1 < height && col + 1 < width ) filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * top_data [ base + width + 1 + i * step ] ; else filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col + 1 < width ) filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * top_data [ base + 1 + i * step ] ; else filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; } } }
void nlf_left_forward_cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top_data ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int col = width - 1 ; col >= 0 ; col -- ) { for ( int row = height - 1 ; row >= 0 ; row -- ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row ; c = col + 1 ; shift = 1 * step + row * width + col ; if ( c < width ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col + 1 ; shift = 2 * step + row * width + col ; if ( c < width && r >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col + 1 ; shift = 3 * step + row * width + col ; if ( c < width && r < height ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col ; shift = 4 * step + row * width + col ; if ( r < height ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; top_data [ base + row * width + col ] = temp ; } } } }
