void add_100 ( int numElements , int * data ) { for ( int idx = 0 ; idx < numElements ; idx ++ ) { data [ idx ] += 100 ; } }
void get_ev ( double * old_arr , double * new_arr , int size ) { int tid ; for ( tid = 0 ; tid < size ; tid ++ ) new_arr [ tid ] = old_arr [ tid ] ; }
void square ( int * array , int arrayCount ) { for ( int idx = 0 ; idx < arrayCount ; idx ++ ) { array [ idx ] *= array [ idx ] ; } }
void add ( int n , float * x , float * y ) { for ( int i = 0 ; i < n ; i ++ ) y [ i ] = x [ i ] + y [ i ] ; }
void scale_host ( float * array , float scale , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { array [ idx ] *= scale ; } return ; }
void allAddInplace_cpu ( double * arr , double alpha , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] += alpha ; } }
void memsetCpuInt ( int * data , int val , int N ) { for ( int index = 0 ; index < N ; index ++ ) { data [ index ] = val ; } }
void initialArray0_cpu ( int tasks , int * f3 ) { for ( int i = 0 ; i < tasks ; i ++ ) { f3 [ i ] = 0 ; } }
void add_vector_cpu ( float * a , float * b , float * c , int size ) { for ( int i = 0 ; i < size ; ++ i ) c [ i ] = a [ i ] + b [ i ] ; }
void test_cpu ( float * input , const int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( tid == 0 ) { input [ tid ] = 0 ; } } }
void set_sorting_offset ( const int nrows , const int ncols , int * offsets ) { int tid ; for ( tid = 0 ; tid <= ncols ; tid ++ ) offsets [ tid ] = tid * nrows ; return ; }
void dot_cpu ( float * c , float * a , float * b , int size ) { int t_id ; for ( t_id = 0 ; t_id < size ; t_id ++ ) c [ t_id ] = a [ t_id ] * b [ t_id ] ; }
void matDiagAddInplace_cpu ( double * mat , double alpha , int dim ) { for ( int i = 0 ; i < dim ; i ++ ) { mat [ i * dim + i ] += alpha ; } }
void cpuAddCorrAndCorrection ( float * L , float * r , int N ) { for ( int u = 0 ; u < N ; u ++ ) { L [ u ] -= r [ u ] ; } }
void fill_cpu ( int N , float ALPHA , float * X , int INCX ) { int i ; for ( i = 0 ; i < N ; ++ i ) X [ i * INCX ] = ALPHA ; }
void scal_cpu ( int N , float ALPHA , float * X , int INCX ) { int i ; for ( i = 0 ; i < N ; ++ i ) X [ i * INCX ] *= ALPHA ; }
void PSIfill_cpu ( float * array , int conv_length , int n ) { for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = array [ i % conv_length ] ; } }
void host_add ( float * c , float * a , float * b , int n ) { for ( int k = 0 ; k < n ; k ++ ) { c [ k ] = a [ k ] + b [ k ] ; } }
void mul_Scalar_matrix ( float * a , float value , float * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] * value ; } }
void initWith_cpu ( float num , float * a , int N ) { for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = num ; } }
void zeroIndices_cpu ( long * vec_out , const long N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { vec_out [ idx ] = vec_out [ idx ] - vec_out [ 0 ] ; } }
void saxpy_serial ( const int dim , float a , float * x , float * y ) { for ( int i = 0 ; i < dim ; i ++ ) y [ i ] += a * x [ i ] ; }
void getCanBusData ( int * canData , int size ) { int idx ; for ( idx = 0 ; idx < size ; idx ++ ) { canData [ idx ] += 1 ; } }
void sum_array_cpu ( float * a , float * b , float * c , const int size ) { for ( int i = 0 ; i < size ; ++ i ) { c [ i ] = a [ i ] + b [ i ] ; } }
void matColMeanDiv_cpu ( double * buf , int m , int n , double * tmp ) { for ( int i = 0 ; i < n ; i ++ ) { buf [ i ] = tmp [ i ] / m ; } }
void dmul_Scalar_matrix ( double * a , double value , double * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] * value ; } }
void countRangesGlobal ( int size , int * A , int * B ) { for ( int i = 0 ; i < size ; i ++ ) { int x = A [ i ] / 100 ; B [ x ] += 1 ; } }
void dsubtract_matrix ( double * a , double * b , double * c , int N ) { for ( int idx = 0 ; idx < N ; idx ++ ) { c [ idx ] = a [ idx ] - b [ idx ] ; } }
void add_arrays ( int n , float * x , float * y , float * z ) { for ( int i = 0 ; i < n ; i ++ ) { z [ i ] = x [ i ] + y [ i ] ; } }
void sum_arrays_cpu ( int * a , int * b , int * c , int size ) { for ( int i = 0 ; i < size ; i ++ ) { c [ i ] = a [ i ] + b [ i ] ; } }
void iKernel_cpu ( float * A , float * B , float * C , const int N ) { for ( int i = 0 ; i < N ; i ++ ) { C [ i ] = A [ i ] + B [ i ] ; } }
void multiplyIntValues ( int * destination , int * vector , int value , unsigned int end ) { for ( unsigned int i = 0 ; i < end ; i ++ ) { destination [ i ] = vector [ i ] * value ; } }
void doubleArrayScalarDivide_cpu ( double * d_in , int * d_out , int length , double scalar ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in [ idx ] / scalar ; } }
void add ( const int x , const int y , const int WIDTH , int * c , const int * a , const int * b ) { int i = y * ( WIDTH ) + x ; c [ i ] = a [ i ] + b [ i ] ; }
void activate_array_leaky_cpu ( float * x , int n ) { for ( int index = 0 ; index < n ; index ++ ) { float val = x [ index ] ; x [ index ] = ( val > 0 ) ? val : val / 10 ; } }
void logistic_cpu ( unsigned int n , float a , float * x , float * z ) { for ( int myId = 0 ; myId < n ; myId ++ ) { z [ myId ] = a * x [ myId ] * ( 1 - x [ myId ] ) ; } }
void add_kernel ( float * inputleft , float * inputright , float * output , int count ) { int idx ; for ( idx = 0 ; idx < count ; idx ++ ) output [ idx ] = inputleft [ idx ] + inputright [ idx ] ; }
void mul_cpu ( int N , float * X , int INCX , float * Y , int INCY ) { int i ; for ( i = 0 ; i < N ; ++ i ) Y [ i * INCY ] *= X [ i * INCX ] ; }
void pathPlan ( int * devSpeed , int * devSteer , int size ) { int tid ; for ( tid = 0 ; tid < size ; tid ++ ) { devSpeed [ tid ] += 1 ; devSteer [ tid ] += 1 ; } }
void mult_add_into_cpu ( int N , float * X , float * Y , float * Z ) { int i ; for ( i = 0 ; i < N ; ++ i ) Z [ i ] += X [ i ] * Y [ i ] ; }
void InitReduction ( int * flags , int voxelCount , int * reduction , int reductionSize ) { int tid ; for ( tid = 0 ; tid < reductionSize ; tid ++ ) reduction [ tid ] = ( tid < voxelCount ) ? flags [ tid ] : 0 ; }
void Function_update_sgd_cpu ( float lr , float * parameter , float * gradient , int size ) { for ( int i = 0 ; i < size ; i ++ ) parameter [ i ] -= lr * gradient [ i ] ; }
void operacionCPU ( float * u , float * lu , float u_m , float u_d , int n ) { int idx = 0 ; while ( idx < n ) { lu [ idx ] = ( u [ idx ] - u_m ) / u_d ; idx += 1 ; } }
void host_add ( float * c , float * a , float * b , int n ) { for ( int k = 0 ; k < n ; k ++ ) { c [ k ] = a [ k ] + b [ k ] ; } }
void squareSerial ( float * d_in , float * d_out , int N ) { for ( unsigned int i = 0 ; i < N ; ++ i ) { d_out [ i ] = pow ( d_in [ i ] / ( d_in [ i ] - 2.3 ) , 3 ) ; } }
void doubleArrayVectorAdd_cpu ( double * d_in_a , double * d_in_b , double * d_out , int length ) { for ( int idx = 0 ; idx < length ; idx ++ ) { d_out [ idx ] = d_in_a [ idx ] + d_in_b [ idx ] ; } }
void fill_matrix ( double * const A , const int rows , const int cols ) { int row , col ; for ( row = 0 ; row < rows ; row ++ ) { for ( col = 0 ; col < cols ; col ++ ) { A [ row * cols + col ] = row ; } } }
void evenoddincrement_cpu ( float * g_data , int even_inc , int odd_inc , int size ) { int tx ; for ( tx = 0 ; tx < size ; tx ++ ) { if ( ( tx % 2 ) == 0 ) { g_data [ tx ] += even_inc ; } else { g_data [ tx ] += odd_inc ; } } }
void copy_cpu ( int N , float * X , int INCX , float * Y , int INCY ) { int i ; for ( i = 0 ; i < N ; ++ i ) Y [ i * INCY ] = X [ i * INCX ] ; }
void clearLabel ( float * prA , float * prB , unsigned int num_nodes , float base ) { unsigned int id ; for ( id = 0 ; id < num_nodes ; id ++ ) { prA [ id ] = base + prA [ id ] * 0.85 ; prB [ id ] = 0 ; } }
void delay_kernel_cpu ( int * N_mobil , int * Tau , int dia ) { int N = N_mobil [ 0 ] ; for ( int id = 0 ; id < N ; id ++ ) { if ( Tau [ id ] > 0 ) Tau [ id ] = Tau [ id ] - 1 ; } }
void resetHeap_cpu ( int * heap , int * heapPtr , int numBlock ) { for ( int index = 0 ; index < numBlock ; index ++ ) { if ( index == 0 ) heapPtr [ 0 ] = numBlock - 1 ; heap [ index ] = numBlock - index - 1 ; } }
void pow_cpu ( int N , float ALPHA , float * X , int INCX , float * Y , int INCY ) { int i ; for ( i = 0 ; i < N ; ++ i ) Y [ i * INCY ] = pow ( X [ i * INCX ] , ALPHA ) ; }
void kComputeActs ( const float * d_nets , float * d_acts , int size ) { int un_idx = 0 ; for ( un_idx = 0 ; un_idx < size ; un_idx ++ ) { float tact = 1.0f / ( 1.0f + expf ( - d_acts [ un_idx ] ) ) ; d_acts [ un_idx ] = tact ; } }
void transpositionCPU ( int * vector , int * transposed , int size ) { for ( int i = 0 ; i < size ; i ++ ) for ( int j = 0 ; j < size ; j ++ ) transposed [ i + j * size ] = vector [ j + i * size ] ; }
void compute_array_square ( float * array , float * outArray , int size ) { for ( int i = 0 ; i < size ; i ++ ) outArray [ i ] = array [ i ] * array [ i ] ; }
void testInt1_cpu ( const int * input , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { int sum ; for ( int i = 0 ; i < 3000 * 4 ; i ++ ) { if ( input [ i ] == 0 ) { sum ++ ; } } } }
void incKernel ( int * g_out , int * g_in , int N , int inner_reps ) { for ( int idx = 0 ; idx < N ; idx ++ ) { for ( int i = 0 ; i < inner_reps ; ++ i ) { g_out [ idx ] = g_in [ idx ] + 1 ; } } }
void forward_dropout_layer ( int batch , int inputs , float * input , float probability , float * rand , float scale ) { int i ; for ( i = 0 ; i < batch * inputs ; ++ i ) { if ( rand [ i ] < probability ) input [ i ] = 0 ; else input [ i ] *= scale ; } }
void boundaryCorrectIndexes_cpu ( int * d_in , int * d_out , int length , int N ) { for ( int idx = 0 ; idx < length ; idx ++ ) { if ( d_in [ idx ] > N ) { d_out [ idx ] = N ; } else { d_out [ idx ] = d_in [ idx ] ; } } }
void upsweep_scan ( int twod , int N , int * output ) { int twod1 = twod * 2 ; int idx ; for ( idx = 0 ; idx + twod1 - 1 < N ; idx += twod1 ) output [ idx + twod1 - 1 ] += output [ idx + twod - 1 ] ; }
void Blend_CPU ( unsigned char * aImg1 , unsigned char * aImg2 , unsigned char * aRS , int width , int height ) { for ( int i = 0 ; i < width * height ; ++ i ) aRS [ i ] = ( unsigned char ) ( 0.5 * aImg1 [ i ] + 0.5 * aImg2 [ i ] ) ; }
void matVecRowSubInplace_cpu ( double * mat , const double * vec , int m , int n ) { for ( int index = 0 ; index < m * n ; index ++ ) { int i = index / n ; int j = index % n ; mat [ i * n + j ] -= vec [ j ] ; } }
void matVecColAddInplace_cpu ( double * mat , const double * vec , int m , int n ) { for ( int index = 0 ; index < m * n ; index ++ ) { int i = index / n ; int j = index % n ; mat [ i * n + j ] += vec [ i ] ; } }
void MMDOuterProdComputeWithSum ( float * x_average , int size_x , float * x_outer_prod ) { for ( int i = 0 ; i < size_x ; i ++ ) { x_outer_prod [ i ] = x_average [ i ] * x_average [ i ] ; } }
void saxpy_cpu ( float * vecY , float * vecX , float alpha , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) vecY [ i ] = alpha * vecX [ i ] + vecY [ i ] ; }
void set_valid_mask_cpu ( const float * score , float score_thr , int * valid_mask , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( score [ tid ] > score_thr ) { valid_mask [ tid ] = 1 ; } else { valid_mask [ tid ] = 0 ; } } }
void copy_swap ( float * f_in , float * f_target , const int L_x ) { int k_x ; for ( k_x = 0 ; k_x < L_x ; k_x ++ ) { float tempval = 0.f ; tempval = f_in [ k_x ] ; f_in [ k_x ] = f_target [ k_x ] ; f_target [ k_x ] = tempval ; } }
void sum_backward ( float * db , float * dout , int r , int c ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int i = 0 ; i < r ; i ++ ) { db [ j ] += dout [ i * c + j ] ; } } }
void is_repeat ( int N , int * device_input , int * device_output ) { int idx ; for ( idx = 0 ; idx < N ; idx ++ ) { device_output [ idx ] = 0 ; if ( idx + 1 < N && device_input [ idx ] == device_input [ idx + 1 ] ) device_output [ idx ] = 1 ; } }
void kmeans_average ( int * means , int * counts , int BID , int DIM ) { int bid ; int tid ; for ( bid = 0 ; bid < BID ; bid ++ ) { for ( tid = 0 ; tid < DIM ; tid ++ ) { if ( counts [ bid ] == 0 ) means [ bid * DIM + tid ] = 0 ; else means [ bid * DIM + tid ] /= counts [ bid ] ; } } }
void matPerRowDivInplace_cpu ( double * mat , const double * alphas , int m , int n ) { for ( int index = 0 ; index < m * n ; index ++ ) { int i = index / n ; int j = index % n ; mat [ i * n + j ] /= ( alphas [ i ] + 10 * 3 ) ; } }
void compute_new_means ( float * mx , float * my , const float * sx , const float * sy , const int * c , int size ) { int cluster = 0 ; const int count = max ( 1 , c [ cluster ] ) ; for ( cluster = 0 ; cluster < size ; cluster ++ ) { mx [ cluster ] = sx [ cluster ] / count ; my [ cluster ] = sy [ cluster ] / count ; } }
void copy_array_d2d ( double * * src , double * * dst , int m , int n ) { int i , j ; for ( i = 1 ; i < m + 1 ; i ++ ) for ( j = 1 ; j < n + 1 ; j ++ ) dst [ i ] [ j ] = src [ i ] [ j ] ; }
void InitCCL ( int labelList [ ] , int reference [ ] , int width , int height ) { int x ; int y ; for ( x = 0 ; x < width ; x ++ ) { for ( y = 0 ; y < height ; y ++ ) { int id = x + y * width ; labelList [ id ] = reference [ id ] = id ; } } }
void cpu_set_sg ( int * sxz , int sxbeg , int szbeg , int jsx , int jsz , int ns , int npml , int nnz ) { for ( int id = 0 ; id < ns ; id ++ ) { sxz [ id ] = nnz * ( sxbeg + id * jsx + npml ) + ( szbeg + id * jsz + npml ) ; } }
void addMatrix ( float * a , float * b , float * c , int N ) { int i , j , idx ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) { idx = i * N + j ; a [ idx ] = b [ idx ] + c [ idx ] ; } }
void resizedClsScore_cpu ( const float * score , const float * score_factors , float * output , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( score [ tid ] == ( -1 ) ) { output [ tid ] = -1 ; } else { output [ tid ] = score [ tid ] * score_factors [ tid ] ; } } }
void l1_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float diff = truth [ i ] - pred [ i ] ; error [ i ] = fabs ( diff ) ; delta [ i ] = diff > 0 ? 1 : -1 ; } }
void AddMatrixOnCPU ( int * A , int * B , int * C , int nx , int ny ) { int i , j ; int cnt = 0 ; for ( j = 0 ; j < ny ; j ++ ) { for ( i = 0 ; i < nx ; i ++ ) { C [ cnt ] = A [ cnt ] + B [ cnt ] ; cnt ++ ; } } }
void LreluForward ( float * srcData , float * dstData , int data_size , float alpha ) { for ( int i = 0 ; i < data_size ; i ++ ) { dstData [ i ] = srcData [ i ] > 0 ? srcData [ i ] : srcData [ i ] * alpha ; } }
void filterFFT_cpu ( float * FFT , float * filter , int nxprj2 , int nviews , float scale ) { for ( int i = 0 ; i < nviews ; i ++ ) { for ( int j = 0 ; i < nxprj2 ; j ++ ) { FFT [ i * nxprj2 + j ] *= filter [ i * nxprj2 + j ] * scale ; } } }
void convertFloatToRGBA_cpu ( char * out_image , const float * in_image , int width , int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { char temp ; int IND = y * width + x ; float val = in_image [ IND ] ; temp = 255 ; out_image [ IND ] = temp ; } } }
void convertEdgeMaskToFloatCpu ( float * d_output , unsigned char * d_input , unsigned int width , unsigned int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { d_output [ y * width + x ] = min ( d_input [ y * width + x ] , d_input [ width * height + y * width + x ] ) ; } } }
void gpu_matrix_transpose ( int * mat_in , int * mat_out , unsigned int rows , unsigned int cols ) { unsigned int idx ; unsigned int idy ; for ( idx = 0 ; idx < cols ; idx ++ ) { for ( idy = 0 ; idy < rows ; idy ++ ) { unsigned int pos = idy * cols + idx ; unsigned int trans_pos = idx * rows + idy ; mat_out [ trans_pos ] = mat_in [ pos ] ; } } }
void LreluBackward ( float * srcDiff , float * dstDiff , float * srcData , int data_size , float alpha ) { for ( int i = 0 ; i < data_size ; i ++ ) { dstDiff [ i ] = ( srcData [ i ] > 0 ) ? srcDiff [ i ] * 1.0 : srcDiff [ i ] * alpha ; } }
int cpuReduce ( int * N , const int size ) { if ( size == 1 ) return N [ 0 ] ; int stride = size / 2 ; for ( int i = 0 ; i < stride ; i ++ ) N [ i ] += N [ i + stride ] ; return cpuReduce ( N , stride ) ; }
void devidecountInnerCPU ( long Xsize , long Ysize , long Zsize , double * p , double * pn , int * pcountinner ) { for ( int tid = 0 ; tid < Xsize * Ysize * Zsize ; tid ++ ) { if ( pcountinner [ tid ] > 1 ) { p [ tid ] = pn [ tid ] / pcountinner [ tid ] ; pn [ tid ] = 0 ; } } }
void cpuConvertToBits ( int * bit_decisions , unsigned short * bit_stream , int dec_size ) { for ( int dec_index = 0 ; dec_index < dec_size ; dec_index ++ ) { int bit_index = dec_index * 2 ; int curr_decision = bit_decisions [ dec_index ] ; bit_stream [ bit_index ] = ( ( curr_decision & 2 ) >> 1 ) ; bit_stream [ bit_index + 1 ] = ( curr_decision & 1 ) ; } }
void copyAliasRow ( int * devMat , int memWidth , int memHeight , int size ) { for ( int devMatX = 0 ; devMat < size ; devMat ++ ) { devMat [ memWidth * 0 + devMatX ] = devMat [ memWidth * ( memHeight - 2 ) + devMatX ] ; devMat [ memWidth * ( memHeight - 1 ) + devMatX ] = devMat [ memWidth * 1 + devMatX ] ; } }
double * ObjFeatures_circularity ( const int compCount , const int * areaRes , const double * perimeter ) { if ( compCount > 0 ) { double * circ = ( double * ) malloc ( compCount * sizeof ( double ) ) ; for ( int i = 0 ; i < compCount ; i ++ ) { circ [ i ] = ( 4.0 * 3.14159265359 * ( double ) areaRes [ i ] ) / ( perimeter [ i ] * perimeter [ i ] ) ; } return circ ; } return ( double * ) 0 ; }
void devidecountCPU ( long Xsize , long Ysize , long Zsize , double * pint , int * pcount ) { int n = Xsize * Ysize * 2 + ( Ysize - 2 ) * Zsize * 2 + ( Xsize - 2 ) * ( Zsize - 2 ) * 2 ; for ( int tid = 0 ; tid < n * n ; tid ++ ) { if ( pcount [ tid ] > 1 ) { pint [ tid ] /= pcount [ tid ] ; } } }
void bubbleSort ( int * p , const int size ) { for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = 0 ; j < size - i - 1 ; j ++ ) { if ( p [ j ] > p [ j + 1 ] ) { int temp = p [ j ] ; p [ j ] = p [ j + 1 ] ; p [ j + 1 ] = temp ; } } } }
void matmul ( int a [ ] [ 100 ] , int b [ ] [ 100 ] , int c [ ] [ 100 ] ) { for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { c [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 100 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } }
void cudaKernel_estimateSnr_cpu ( const float * corrSum , const int * corrValidCount , const float * maxval , float * snrValue , const int size ) { for ( int idx = 0 ; idx < size ; idx ++ ) { float mean = ( corrSum [ idx ] - maxval [ idx ] * maxval [ idx ] ) / ( corrValidCount [ idx ] - 1 ) ; snrValue [ idx ] = maxval [ idx ] * maxval [ idx ] / mean ; } }
void cpu_sgemm ( float * C , float * A , float * B , long size ) { for ( long i = 0 ; i < size ; i ++ ) { for ( long k = 0 ; k < size ; k ++ ) { for ( long j = 0 ; j < size ; j ++ ) { C [ i * size + j ] += A [ i * size + k ] * B [ k * size + j ] ; } } } }
void kernelXor ( unsigned int key , char * input_str_cuda , unsigned char * possible_plaintext_str_cuda , int input_length ) { int id ; char * keyCharPtr ; for ( id = 0 ; id < input_length ; id ++ ) { int keyIndex = id % 4 ; keyCharPtr = ( ( char * ) & key ) ; char keyChar = keyCharPtr [ keyIndex ] ; possible_plaintext_str_cuda [ id ] = keyChar ^ input_str_cuda [ id ] ; } }
void envejecer_kernel_cpu ( int * estado , int * edad , int * pupacion , int * N_mobil , int dia ) { int N = N_mobil [ 0 ] ; for ( int id = 0 ; id < N ; id ++ ) { if ( dia < 80 || dia > 320 ) { if ( edad [ id ] > pupacion [ id ] ) edad [ id ] ++ ; } else { edad [ id ] ++ ; } } }
void globalCalculateKernel ( float * c , float * a , float * b , int size ) { int i ; int j ; for ( i = 0 ; i < size ; i ++ ) { for ( j = 0 ; j < size ; j ++ ) { c [ i * j ] = sin ( a [ i * j ] ) * sin ( a [ i * j ] ) + cos ( b [ i * j ] ) * cos ( b [ i * j ] ) * cos ( b [ i * j ] ) ; } } }
void cpu_matrix_mul ( int * a , int * b , int * c , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ row * N + i ] * b [ i * N + col ] ; } c [ row * N + col ] = sum ; } } }
void grayscale ( unsigned char * input , unsigned char * output , int size ) { unsigned char r , g , b ; for ( int i = 0 ; i < size ; i ++ ) { r = input [ 3 * i ] ; g = input [ 3 * i + 1 ] ; b = input [ 3 * i + 2 ] ; output [ i ] = ( unsigned char ) ( 0.21 * ( float ) r + 0.71 * ( float ) g + 0.07 * ( float ) b ) ; } }
void subtractMean_cpu ( double * images , const double * meanImage , int imageNum , int pixelNum ) { for ( int col = 0 ; col < pixelNum ; col ++ ) { for ( int row = 0 ; row < imageNum ; ++ row ) { images [ row * pixelNum + col ] -= meanImage [ col ] ; if ( images [ row * pixelNum + col ] < 0.0 ) { images [ row * pixelNum + col ] = 0.0 ; } } } }
void kernelMaximum ( float * maxhd , float * maxvd , int start , int size ) { int tx = start ; int max_hd = 1.175494351e-38F ; int max_vd = 1.175494351e-38F ; for ( ; tx < size ; tx ++ ) { if ( maxhd [ tx ] > max_hd ) max_hd = maxhd [ tx ] ; if ( maxvd [ tx ] > max_vd ) max_vd = maxvd [ tx ] ; } }
void SparseMatmul_forward ( float * a , float * b , float * c , int * indptr , int * indices , int p , int size ) { for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int jj = indptr [ i ] ; jj < indptr [ i + 1 ] ; jj ++ ) { int j = indices [ jj ] ; for ( int k = 0 ; k < p ; k ++ ) c [ i * p + k ] += a [ jj ] * b [ j * p + k ] ; } } }
void vectorMatrixMult ( long int totalPixels , int availablePixels , int outPixelOffset , float * matrix , float * vector , float * out ) { for ( long int i = 0 ; i < availablePixels ; i ++ ) { float sum = 0.0 ; for ( long int j = 0 ; j < totalPixels ; j ++ ) { sum += matrix [ i * totalPixels + j ] * vector [ j ] ; } out [ i + outPixelOffset ] = sum ; } }
void convertKinectDisparityInPlace_cpu ( float * d_disparity , int pitch , int width , int height , float depth_scale ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { float * d_in = ( float * ) ( ( char * ) d_disparity + y * pitch ) + x ; * d_in = ( * d_in == 0.0f ) ? 1 : ( - depth_scale / * d_in ) ; } } }
void SparseMatmul_backward ( float * a , float * b_grad , float * c_grad , int * indptr , int * indices , int p , int size , float * grad ) { for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int jj = indptr [ i ] ; jj < indptr [ i + 1 ] ; jj ++ ) { int j = indices [ jj ] ; for ( int k = 0 ; k < p ; k ++ ) b_grad [ j * p + k ] += c_grad [ i * p + k ] * a [ jj ] ; } } }
void subsample_ind_and_labels_cpu ( int * d_ind_sub , const int * d_ind , unsigned int * d_label_sub , const unsigned int * d_label , int n_out , float inv_sub_factor ) { for ( int ind_out = 0 ; ind_out < n_out ; ind_out ++ ) { int ind_in = ( int ) floorf ( ( float ) ( ind_out ) * inv_sub_factor ) ; d_ind_sub [ ind_out ] = d_ind [ ind_in ] ; d_label_sub [ ind_out ] = d_label [ ind_in ] ; } }
void mxm_1d_cpu ( double * a , const int m , double * b , const int n , double * c , const int p ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int k = 0 ; k < p ; k ++ ) { double s = 0.0 ; for ( int j = 0 ; j < n ; j ++ ) { s += a [ j * m + i ] * b [ k * n + j ] ; } c [ k * m + i ] = s ; } } }
void fabsf_clamp_cpu ( int N , float * X , int INCX , float clamp_min , float clamp_max ) { int i ; for ( i = 0 ; i < N ; ++ i ) { if ( X [ i * INCX ] >= 0 ) { X [ i * INCX ] = fmin ( clamp_max , fmax ( clamp_min , X [ i * INCX ] ) ) ; } else { X [ i * INCX ] = fmin ( - clamp_min , fmax ( - clamp_max , X [ i * INCX ] ) ) ; } } }
void cpu_matrix_mult ( int * h_a , int * h_b , int * h_result , int m , int n , int k ) { for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < k ; ++ j ) { int tmp = 0.0 ; for ( int h = 0 ; h < n ; ++ h ) { tmp += h_a [ i * n + h ] * h_b [ h * k + j ] ; } h_result [ i * k + j ] = tmp ; } } }
inline void MulMatrixOnCPU ( float * A , float * B , float * C , int nx , int ny ) { int i , j , k ; float sum = 0.0 ; for ( i = 0 ; i < nx ; i ++ ) { for ( j = 0 ; j < ny ; j ++ ) { sum = 0.0 ; for ( k = 0 ; k < nx ; k ++ ) { sum = sum + A [ i * nx + k ] * B [ k * nx + j ] ; } C [ i * nx + j ] = sum ; } } }
int matrixMulHost ( float * h_M , float * h_N , float * h_P , int width ) { int Pvalue ; for ( int row = 0 ; row < width ; ++ row ) { for ( int col = 0 ; col < width ; ++ col ) { Pvalue = 0 ; for ( int k = 0 ; k < width ; ++ k ) { Pvalue += h_M [ row * width + k ] * h_N [ k * width + col ] ; } h_P [ row * width + col ] = Pvalue ; } } return 0 ; }
void mmul_cpu ( const float * A , const float * B , float * C , int r1 , int c1 , int r2 , int c2 ) { for ( int idx = 0 ; idx < c2 ; idx ++ ) { for ( int idy = 0 ; idy < c1 ; idy ++ ) { float temp = 0 ; for ( int i = 0 ; i < c1 ; i ++ ) temp += A [ idy * c1 + i ] * B [ i * c2 + idx ] ; C [ idy * c2 + idx ] = temp ; } } }
void Dot ( float * C , float * A , float * B , const int r , const int c , const int n ) { float temp ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { temp = 0.0 ; for ( int k = 0 ; k < n ; k ++ ) { temp += A [ i * n + k ] * B [ k * c + j ] ; } C [ i * c + j ] = temp ; } } }
void Forwardsub_cpu ( double * RES , double * LS , double * LW , double * LPR , int NI , int NJ , int Start , int J , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int IJ = ( ( Start + i ) * NI ) + ( J - ( Start + i ) ) ; RES [ IJ ] = ( RES [ IJ ] - LS [ IJ ] * RES [ IJ - 1 ] - LW [ IJ ] * RES [ IJ - NJ ] ) * LPR [ IJ ] ; } }
void cpu_rows_dc_offset_remove_layer_kernel ( float * output , float * input , unsigned int width , unsigned height , unsigned int depth ) { for ( unsigned int channel = 0 ; channel < depth ; channel ++ ) for ( unsigned int row = 0 ; row < height ; row ++ ) for ( unsigned int column = 0 ; column < ( width - 1 ) ; column ++ ) { unsigned int idx = ( channel * height + row ) * width + column ; output [ idx ] = input [ idx ] - input [ idx + 1 ] ; } }
void cpu_cross_correlate ( float * Isg , float * Iss , float * sp , float * gp , int npml , int nnz , int nnx ) { for ( int i1 = npml ; i1 < nnz - npml ; i1 ++ ) { for ( int i2 = npml ; i2 < nnx - npml ; i2 ++ ) { int id = i1 + i2 * nnz ; float ps = sp [ id ] ; float pg = gp [ id ] ; Isg [ id ] += ps * pg ; Iss [ id ] += ps * ps ; } } }
void colorConvert ( unsigned char * grayImage , unsigned char * colorImage , int rows , int columns ) { int column ; int row ; for ( column = 0 ; column < columns ; column ++ ) { for ( row = 0 ; row < rows ; row ++ ) { int offset = ( column ) + ( columns * row ) ; unsigned char grayValue = 0.07 * colorImage [ offset * 3 ] + 0.71 * colorImage [ offset * 3 + 1 ] + 0.21 * colorImage [ offset * 3 + 2 ] ; grayImage [ offset ] = grayValue ; } } }
void init_image_array_CPU ( unsigned long long int * image , int pixels_per_image ) { for ( int my_pixel = 0 ; my_pixel < pixels_per_image ; my_pixel ++ ) { image [ my_pixel ] = ( unsigned long long int ) ( 0 ) ; my_pixel += pixels_per_image ; image [ my_pixel ] = ( unsigned long long int ) ( 0 ) ; my_pixel += pixels_per_image ; image [ my_pixel ] = ( unsigned long long int ) ( 0 ) ; my_pixel += pixels_per_image ; image [ my_pixel ] = ( unsigned long long int ) ( 0 ) ; } }
void diffusion ( const double * x0 , double * x1 , int nx , int ny , double dt ) { int i , j ; auto width = nx + 2 ; for ( j = 1 ; j < ny + 1 ; ++ j ) { for ( i = 1 ; i < nx + 1 ; ++ i ) { auto pos = i + j * width ; x1 [ pos ] = x0 [ pos ] + dt * ( -4. * x0 [ pos ] + x0 [ pos - width ] + x0 [ pos + width ] + x0 [ pos - 1 ] + x0 [ pos + 1 ] ) ; } } }
void compute_b_minus_Rx ( double * out , double * x , double * b , double * cotans , int * neighbors , int meshStride , int n ) { for ( int i = 0 ; i < n ; i ++ ) { out [ i ] = b [ i ] ; for ( int iN = 0 ; iN < meshStride ; ++ iN ) { int neighbor = neighbors [ i * meshStride + iN ] ; double weight = cotans [ i * meshStride + iN ] ; out [ i ] += weight * x [ neighbor ] ; } } }
void binarize_weights ( float * weights , int n , int size , float * binary ) { int i , f ; for ( f = 0 ; f < n ; ++ f ) { float mean = 0 ; for ( i = 0 ; i < size ; ++ i ) { mean += fabs ( weights [ f * size + i ] ) ; } mean = mean / size ; for ( i = 0 ; i < size ; ++ i ) { binary [ f * size + i ] = ( weights [ f * size + i ] > 0 ) ? mean : - mean ; } } }
void gather_points_kernel ( int b , int c , int n , int m , const float * points , const int * idx , float * out ) { for ( int i = 0 ; i < b ; i ++ ) { for ( int l = 0 ; l < c ; l ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int a = idx [ i * m + j ] ; out [ ( i * c + l ) * m + j ] = points [ ( i * c + l ) * n + a ] ; } } } }
void matrix_mult ( int left_rows , int shared_dimensions , int right_columns , float * left , float * right , float * result ) { int row ; int column ; int cell ; for ( row = 0 ; row < left_rows ; row ++ ) { for ( column = 0 ; column < right_columns ; column ++ ) { result [ row * right_columns + column ] = 0 ; for ( cell = 0 ; cell < shared_dimensions ; cell ++ ) { result [ row * right_columns + column ] += left [ row * shared_dimensions + cell ] * right [ cell * right_columns + column ] ; } } } }
void matrixMultiplication_cpu ( int * host_a , int * host_b , int * host_c , int row_a , int col_a , int col_b ) { for ( int i = 0 ; i < row_a ; ++ i ) { for ( int j = 0 ; j < col_b ; ++ j ) { int tmp = 0 ; for ( int k = 0 ; k < col_a ; ++ k ) { tmp += host_a [ i * col_a + k ] * host_b [ j * col_b + k ] ; } host_c [ i * col_b + j ] = tmp ; } } }
void Backwardsub ( double * U , double * RES , double * UN , double * UE , double * LPR , int NI , int NJ , int End , int J , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int IJ = ( ( End - i ) * NI ) + ( J - ( End - i ) ) ; RES [ IJ ] = RES [ IJ ] - UN [ IJ ] * RES [ IJ + 1 ] - UE [ IJ ] * RES [ IJ + NJ ] ; U [ IJ ] = U [ IJ ] + RES [ IJ ] ; } }
void convolution_cpu_1d ( float * input , const float * mask , float * output , int array_size , int mask_size ) { int MASK_RADIUS = mask_size / 2 ; float temp = 0.0f ; int ELEMENT_INDEX = 0 ; for ( int i = 0 ; i < array_size ; i ++ ) { temp = 0 ; for ( int j = 0 ; j < mask_size ; j ++ ) { ELEMENT_INDEX = i - MASK_RADIUS + j ; if ( ! ( ELEMENT_INDEX < 0 || ELEMENT_INDEX > ( array_size - 1 ) ) ) { temp += input [ ELEMENT_INDEX ] * mask [ j ] ; } } output [ i ] = temp ; } }
void getRho ( const int numOfNucl , const double * psi , const double * occNo , double * rho , const char debug ) { * rho = 0 ; for ( int i = 0 ; i < numOfNucl ; ++ i ) * rho += occNo [ i ] * psi [ i ] * psi [ i ] ; if ( debug == 1 ) printf ( " DEBUG ▁ print ▁ of ▁ RHO : \n ▁ RHO ▁ = ▁ % f \n This ▁ is ▁ the ▁ last ▁ line ( RHO ) . \n \n " , * rho ) ; }
void colLog2SumExp2_cpu ( const double * mat , double * buf , int m , int n ) { for ( int j = 0 ; j < n ; j ++ ) { double maximum = mat [ j ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( mat [ i * n + j ] > maximum ) { maximum = mat [ i * n + j ] ; } } double res = 0.0 ; for ( int i = 0 ; i < m ; i ++ ) { res += mat [ i * n + j ] - maximum ; } buf [ j ] = res + maximum ; } }
void bitPrune_cpu ( unsigned char * out , float * in , int frontPrune , int outputlength , int inputLength , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int batch = i / outputlength ; int indexInBatch = i % outputlength ; int batchInJump = batch * inputLength ; int indexOutBatch = i % outputlength ; int batchOutJump = batch * outputlength ; int frontJump = frontPrune ; out [ batchOutJump + indexOutBatch ] = ( char ) ( in [ batchInJump + frontJump + indexInBatch ] > 0 ) ; } }
void residual ( double * out , double * x , double * b , double * cotans , int * neighbors , double * diag , int meshStride , int n ) { for ( int i = 0 ; i < n ; i ++ ) { out [ i ] = diag [ i ] * x [ i ] - b [ i ] ; for ( int iN = 0 ; iN < meshStride ; ++ iN ) { int neighbor = neighbors [ i * meshStride + iN ] ; double weight = cotans [ i * meshStride + iN ] ; out [ i ] -= weight * x [ neighbor ] ; } } }
void forward_avgpool_layer ( int batch , int c , int h , int w , float * input , float * output ) { int b , i , k ; for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < c ; ++ k ) { int out_index = k + b * c ; output [ out_index ] = 0 ; for ( i = 0 ; i < h * w ; ++ i ) { int in_index = i + h * w * ( k + b * c ) ; output [ out_index ] += input [ in_index ] ; } output [ out_index ] /= h * w ; } } }
void convolutionColumnCPU ( float * h_Dst , float * h_Src , float * h_Filter , int imageW , int imageH , int filterR ) { int x , y , k ; for ( y = 0 ; y < imageH ; y ++ ) { for ( x = 0 ; x < imageW ; x ++ ) { float sum = 0 ; for ( k = - filterR ; k <= filterR ; k ++ ) { int d = y + k ; if ( d >= 0 && d < imageH ) { sum += h_Src [ d * imageW + x ] * h_Filter [ filterR - k ] ; } h_Dst [ y * imageW + x ] = sum ; } } } }
void matrMult ( float * A , float * B , float * C , int rowsA , int colsA , int colsB ) { for ( int i = 0 ; i < rowsA ; ++ i ) { for ( int j = 0 ; j < colsB ; ++ j ) { for ( int k = 0 ; k < colsA ; ++ k ) { C [ i * colsB + j ] += A [ i * colsA + k ] * B [ k * colsB + j ] ; } } } }
void add_sources_d ( const float * const model , float * wfp , const float * const source_amplitude , const int * const sources_z , const int * const sources_x , const int nz , const int nx , const int nt , const int ns , const int it ) { int x ; int b ; for ( x = 0 ; x < nx ; x ++ ) { for ( b = 0 ; b < ns ; b ++ ) { int i = sources_z [ b * ns + x ] * nx + sources_x [ b * ns + x ] ; int ib = b * nz * nx + i ; wfp [ ib ] += source_amplitude [ b * ns * nt + x * nt + it ] * model [ i ] ; } } }
void variance_cpu ( float * x , float * mean , int batch , int filters , int spatial , float * variance ) { float scale = 1. / ( batch * spatial - 1 ) ; int i , j , k ; for ( i = 0 ; i < filters ; ++ i ) { variance [ i ] = 0 ; for ( j = 0 ; j < batch ; ++ j ) { for ( k = 0 ; k < spatial ; ++ k ) { int index = j * filters * spatial + i * spatial + k ; variance [ i ] += pow ( ( x [ index ] - mean [ i ] ) , 2 ) ; } } variance [ i ] *= scale ; } }
void grad_y_cpu ( const float * u , float * grad , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long size2d = rows * cols ; unsigned long long idx = z * size2d + y * cols + x ; float uidx = u [ idx ] ; if ( y - 1 >= 0 ) { grad [ idx ] = ( uidx - u [ z * size2d + ( y - 1 ) * cols + x ] ) ; } } } } }
void grad_x_cpu ( const float * u , float * grad , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long size2d = rows * cols ; unsigned long long idx = z * size2d + y * cols + x ; float uidx = u [ idx ] ; if ( x - 1 >= 0 ) { grad [ idx ] = ( uidx - u [ z * size2d + y * cols + ( x - 1 ) ] ) ; } } } } }
void GraphSum_forward ( float * in , float * out , int * indptr , int * indices , int dim , int size ) { for ( int src = 0 ; src < indptr - 1 ; src ++ ) { for ( int i = indptr [ src ] ; i < indptr [ src + 1 ] ; i ++ ) { int dst = indices [ i ] ; float coef = 1.0 / sqrtf ( ( indptr [ src + 1 ] - indptr [ src ] ) * ( indptr [ dst + 1 ] - indptr [ dst ] ) ) ; for ( int j = 0 ; j < dim ; j ++ ) out [ src * dim + j ] += coef * in [ dst * dim + j ] ; } } }
void apply_grayscale ( const unsigned char * image , unsigned char * grayimg , int width , int height ) { for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { const unsigned char R = image [ ( y * width + x ) * 3 + 0 ] ; const unsigned char G = image [ ( y * width + x ) * 3 + 1 ] ; const unsigned char B = image [ ( y * width + x ) * 3 + 2 ] ; unsigned char gray = ( 307 * R + 604 * G + 113 * B ) >> 10 ; grayimg [ y * width + x ] = gray ; } } }
void getOffsetBox_cpu ( const int * clsIndex , const float * max_coordinate , float * offset , int dims , int batchSize , const float * before_nms_boxes ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { int numPerbatch = dims ; for ( int i = 0 ; i < batchSize ; i ++ ) { if ( before_nms_boxes [ i * dims * 4 + tid * 4 ] == ( -1 ) ) { offset [ i * numPerbatch + tid ] = 0 ; } else { offset [ i * numPerbatch + tid ] = clsIndex [ i * numPerbatch + tid ] * ( max_coordinate [ i * dims * 4 ] + 1 ) ; } } } }
void sgemm_kernelCPU ( const float * host_inputArray1 , const float * host_inputArray2 , float * host_inputArray3 , int M , int N , int K , float alpha , float beta ) { for ( int row = 0 ; row < M ; row ++ ) { for ( int column = 0 ; column < N ; column ++ ) { float element_c = 0.f ; for ( int e = 0 ; e < K ; e ++ ) { element_c += host_inputArray1 [ row * K + e ] * host_inputArray2 [ e * N + column ] ; } host_inputArray3 [ row * N + column ] = alpha * element_c + beta * host_inputArray3 [ row * N + column ] ; } } }
void GraphSum_backward ( float * in_grad , float * out_grad , int * indptr , int * indices , int size , int dim ) { for ( int src = 0 ; src < size - 1 ; src ++ ) { for ( int i = indptr [ src ] ; i < indptr [ src + 1 ] ; i ++ ) { int dst = indices [ i ] ; float coef = 1.0 / sqrtf ( ( indptr [ src + 1 ] - indptr [ src ] ) * ( indptr [ dst + 1 ] - indptr [ dst ] ) ) ; for ( int j = 0 ; j < dim ; j ++ ) in_grad [ src * dim + j ] += coef * out_grad [ dst * dim + j ] ; } } }
void CDFfunction ( float * median , float * stdvLogNormalFrame , float * MeanLogNormalFrame , unsigned char * currentFrame , int pixelsPerFrame ) { int pixel ; for ( pixel = 0 ; pixel < pixelsPerFrame ; pixel ++ ) { float newvalue ; float x = currentFrame [ pixel ] ; newvalue = - ( ( log ( x ) - median [ pixel ] ) - MeanLogNormalFrame [ pixel ] ) / ( sqrt ( 2.0 ) * stdvLogNormalFrame [ pixel ] ) ; float summ = 0.5f + 0.5f * erf ( newvalue ) ; if ( summ >= 0.3 ) { currentFrame [ pixel ] = ( unsigned char ) 255 ; } else { currentFrame [ pixel ] = ( unsigned char ) 0 ; } } }
void mul ( float * M , float * N , float * K , float height_M , float width_N , float width_M ) { for ( int i = 0 ; i < height_M ; i ++ ) { for ( int j = 0 ; j < width_N ; j ++ ) { float sum = 0 ; for ( int k = 0 ; k < width_M ; k ++ ) { float a = M [ i * ( int ) width_M + k ] ; float b = N [ k * ( int ) width_N + j ] ; sum += a * b ; } K [ i * ( int ) width_N + j ] = sum ; } } }
void softmax_x_ent_cpu ( int n , float * pred , float * truth , float * delta , float * error ) { int i ; for ( i = 0 ; i < n ; ++ i ) { float t = truth [ i ] ; float p = pred [ i ] ; error [ i ] = ( t ) ? - log ( p ) : 0 ; delta [ i ] = t - p ; } }
void normalize_img ( double * image , long int image_size , int bands ) { long int i , j ; long int row ; double * D = ( double * ) calloc ( image_size , sizeof ( double ) ) ; for ( i = 0 ; i < image_size * bands ; i ++ ) { D [ i % image_size ] += image [ i ] ; } for ( i = 0 ; i < image_size ; i ++ ) { D [ i ] = powf ( D [ i ] + 1.0e-16 , -1 ) ; } for ( i = 0 ; i < bands ; i ++ ) { row = i * image_size ; for ( j = 0 ; j < image_size ; j ++ ) { image [ row + j ] = image [ row + j ] * D [ j ] ; } } free ( D ) ; }
void permuteData_cpu ( const float * input , float * output , int num , int devideNum , int featureSize , int priorNum , int batchSize ) { for ( int tid = 0 ; tid < num ; tid ++ ) { int numPerbatch = num * devideNum * priorNum ; for ( int s = 0 ; s < batchSize ; s ++ ) { for ( int i = 0 ; i < priorNum ; i ++ ) { for ( int j = 0 ; j < devideNum ; j ++ ) { output [ s * numPerbatch + tid * priorNum * devideNum + i * devideNum + j ] = input [ s * numPerbatch + ( i * devideNum * featureSize ) + ( j * featureSize ) + tid ] ; } } } } }
void cpuSimpleCorrelator ( float * xi , float * xq , float * sr , float * si , int sLength , float * L , int uLength ) { for ( int u = 0 ; u < uLength ; u ++ ) { float real = 0 ; float imag = 0 ; float a , b , c , d ; for ( int n = u ; n < u + sLength ; n ++ ) { a = xi [ n ] ; b = xq [ n ] ; c = sr [ n - u ] ; d = si [ n - u ] * ( -1 ) ; real += ( a * c ) - ( b * d ) ; imag += ( a * d ) + ( b * c ) ; } L [ u ] = sqrt ( real * real + imag * imag ) ; } }
void convertKinectDisparityToRegularDisparity_cpu ( float * d_regularDisparity , int d_regularDisparityPitch , const float * d_KinectDisparity , int d_KinectDisparityPitch , int width , int height ) { for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { float d_in = * ( ( float * ) ( ( char * ) d_KinectDisparity + y * d_KinectDisparityPitch ) + x ) ; float d_out = ( d_in == 0.0f ) ? 1 : - d_in ; * ( ( float * ) ( ( char * ) d_regularDisparity + y * d_regularDisparityPitch ) + x ) = d_out ; } } }
void runFilterCpu ( float * I , float * Q , int samplesLength , float * filter , int filterLength , float * filtered_I , float * filtered_Q , int convLength ) { for ( int sampleIndex = 0 ; sampleIndex < convLength ; sampleIndex ++ ) { int index ; float sumI , sumQ ; sumI = 0 ; sumQ = 0 ; for ( int j = sampleIndex - filterLength + 1 ; j <= sampleIndex ; j ++ ) { index = sampleIndex - j ; if ( ( j < samplesLength ) && ( j >= 0 ) ) { sumI += filter [ index ] * I [ j ] ; sumQ += filter [ index ] * Q [ j ] ; } } filtered_I [ sampleIndex ] = sumI ; filtered_Q [ sampleIndex ] = sumQ ; } }
void l2normalize_cpu ( float * x , float * dx , int batch , int filters , int spatial ) { int b , f , i ; for ( b = 0 ; b < batch ; ++ b ) { for ( i = 0 ; i < spatial ; ++ i ) { float sum = 0 ; for ( f = 0 ; f < filters ; ++ f ) { int index = b * filters * spatial + f * spatial + i ; sum += powf ( x [ index ] , 2 ) ; } sum = sqrtf ( sum ) ; for ( f = 0 ; f < filters ; ++ f ) { int index = b * filters * spatial + f * spatial + i ; x [ index ] /= sum ; dx [ index ] = ( 1 - x [ index ] ) / sum ; } } } }
void distanceMatCalc ( long int totalPixels , int availablePixels , int outPixelOffset , int patchSize , float * distMat , float * data , float filtSig ) { for ( long int i = 0 ; i < availablePixels * totalPixels ; i ++ ) { int data_i = i / totalPixels + outPixelOffset ; int data_j = i % totalPixels ; float tmp = 0.0 ; if ( data_i != data_j ) { for ( int elem = 0 ; elem < patchSize * patchSize ; elem ++ ) { float diff = ( data [ data_i * patchSize * patchSize + elem ] - data [ data_j * patchSize * patchSize + elem ] ) ; tmp += diff * diff ; } tmp = exp ( - tmp / ( filtSig ) ) ; } distMat [ i ] = tmp ; } }
void shortcut_kernel_cpu ( int size , int minw , int minh , int minc , int stride , int sample , int batch , int w1 , int h1 , int c1 , float * add , int w2 , int h2 , int c2 , float * out ) { for ( int id = 0 ; id < size ; id ++ ) { int i = id % minw ; id /= minw ; int j = id % minh ; id /= minh ; int k = id % minc ; id /= minc ; int b = id % batch ; int out_index = i * sample + w2 * ( j * sample + h2 * ( k + c2 * b ) ) ; int add_index = i * stride + w1 * ( j * stride + h1 * ( k + c1 * b ) ) ; out [ out_index ] += add [ add_index ] ; } }
float dot_cpu ( int N , float * X , int INCX , float * Y , int INCY ) { int i ; float dot = 0 ; for ( i = 0 ; i < N ; ++ i ) dot += X [ i * INCX ] * Y [ i * INCY ] ; return dot ; }
void k_adam_kernel ( float * m , float * v , float * w , const float * d , int max_size , float beta1 , float beta2 , float beta1_tpower , float beta2_tpower , float learning_rate ) { const float eps = 1e-8 ; for ( int i = 0 ; i < max_size ; i ++ ) { float d_temp = d [ i ] ; m [ i ] = m [ i ] * beta1 + d_temp * ( 1 - beta1 ) ; v [ i ] = v [ i ] * beta2 + d_temp * d_temp * ( 1 - beta2 ) ; float m_hat = m [ i ] / ( 1 - beta1_tpower ) ; float v_hat = sqrt ( v [ i ] / ( 1 - beta2_tpower ) ) + eps ; w [ i ] += ( m_hat / v_hat ) * ( - learning_rate ) ; } }
void convLayer_forward ( int N , int M , int C , int H , int W , int K , float * X , float * Wk , float * Y ) { int n , m , c , h , w , p , q ; int H_out = H - K + 1 ; int W_out = W - K + 1 ; for ( n = 0 ; n < N ; n ++ ) for ( m = 0 ; m < M ; m ++ ) for ( h = 0 ; h < H_out ; h ++ ) for ( w = 0 ; w < W_out ; w ++ ) { Y [ n , m , h , w ] = 0 ; for ( c = 0 ; c < C ; c ++ ) for ( p = 0 ; p < K ; p ++ ) for ( q = 0 ; q < K ; q ++ ) Y [ n , m , h , w ] += X [ n , c , h + p , w + q ] * Wk [ m , c , p , q ] ; } }
void opL23_cpu ( float * vec , float * vec1 , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long long i = z * rows * cols + y * cols + x ; unsigned long long j = z * rows * cols + y * cols ; unsigned long size2d = cols ; unsigned long size3d = depth * rows * cols + rows * cols + cols ; if ( i + cols + 1 >= size3d ) return ; vec [ i + cols ] = 0.5 * ( vec1 [ i + cols ] + vec1 [ i ] ) ; if ( j + 1 >= size2d ) return ; vec [ j ] = 0.5 * ( vec1 [ j ] ) ; } } } }
void upsample_cpu ( float * in , int w , int h , int c , int batch , int stride , int forward , float scale , float * out ) { int i , j , k , b ; for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < c ; ++ k ) { for ( j = 0 ; j < h * stride ; ++ j ) { for ( i = 0 ; i < w * stride ; ++ i ) { int in_index = b * w * h * c + k * w * h + ( j / stride ) * w + i / stride ; int out_index = b * w * h * c * stride * stride + k * w * h * stride * stride + j * w * stride + i ; if ( forward ) out [ out_index ] = scale * in [ in_index ] ; else in [ in_index ] += scale * out [ out_index ] ; } } } } }
void rgb2yuv_kernel ( int img_size , unsigned char * gpu_img_in_r , unsigned char * gpu_img_in_g , unsigned char * gpu_img_in_b , unsigned char * gpu_img_out_y , unsigned char * gpu_img_out_u , unsigned char * gpu_img_out_v ) { unsigned char r , g , b ; int index ; for ( index = 0 ; index < img_size ; index ++ ) { r = gpu_img_in_r [ index ] ; g = gpu_img_in_g [ index ] ; b = gpu_img_in_b [ index ] ; gpu_img_out_y [ index ] = ( unsigned char ) ( 0.299 * r + 0.587 * g + 0.114 * b ) ; gpu_img_out_u [ index ] = ( unsigned char ) ( -0.169 * r - 0.331 * g + 0.499 * b + 128 ) ; gpu_img_out_v [ index ] = ( unsigned char ) ( 0.499 * r - 0.418 * g - 0.0813 * b + 128 ) ; } }
void getDRho ( const int numOfNucl , const double * psi , const double * * dpsi , const double * occNo , double * drho , const char debug ) { drho [ 0 ] = 0 ; drho [ 1 ] = 0 ; drho [ 2 ] = 0 ; for ( int i = 0 ; i < numOfNucl ; ++ i ) { drho [ 0 ] = drho [ 0 ] + 2 * occNo [ i ] * psi [ i ] * dpsi [ i ] [ 0 ] ; drho [ 1 ] = drho [ 1 ] + 2 * occNo [ i ] * psi [ i ] * dpsi [ i ] [ 1 ] ; drho [ 2 ] = drho [ 2 ] + 2 * occNo [ i ] * psi [ i ] * dpsi [ i ] [ 2 ] ; } if ( debug == 1 ) printf ( " DEBUG ▁ print ▁ of ▁ DRHO : \n ▁ \t % f\t % f\t % f \n This ▁ is ▁ the ▁ last ▁ line ( DRHO ) . \n \n " , drho [ 0 ] , drho [ 1 ] , drho [ 2 ] ) ; }
void opL12_cpu ( float * vec , float * vec1 , long depth , long rows , long cols ) { for ( int x = 0 ; x < cols ; x ++ ) { for ( int y = 0 ; y < rows ; y ++ ) { for ( int z = 0 ; z < depth ; x ++ ) { unsigned long long i = z * rows * cols + y * cols + x ; unsigned long long j = z * rows * cols + y * cols ; unsigned long size2d = cols ; unsigned long size3d = depth * rows * cols + rows * cols + cols ; if ( i + cols + 1 >= size3d ) return ; vec [ i + 1 ] = 0.25 * ( vec1 [ i + 1 ] + vec1 [ i ] + vec1 [ i + cols + 1 ] + vec1 [ i + cols ] ) ; if ( j + 1 >= size2d ) return ; vec [ j ] = 0.25 * ( vec1 [ j ] + vec1 [ j + cols ] ) ; } } } }
void cpuBYUSimplified ( float * xi , float * xq , float * sr , float * si , int N , int Lq , float * L ) { for ( int u = 0 ; u < N ; u ++ ) { float uSum = 0 ; float r_i , r_q , q_i , q_q ; float realPart , imagPart ; for ( int k = 0 ; k <= 7 ; k ++ ) { realPart = 0 ; imagPart = 0 ; for ( int l = 0 ; l < Lq ; l ++ ) { r_i = xi [ u + k * Lq + l ] ; r_q = xq [ u + k * Lq + l ] ; q_i = sr [ l ] ; q_q = si [ l ] * ( -1 ) ; realPart += ( r_i * q_i ) - ( r_q * q_q ) ; imagPart += ( r_i * q_q ) + ( r_q * q_i ) ; } uSum += ( realPart * realPart ) + ( imagPart * imagPart ) ; } L [ u ] = uSum ; } }
void shortcut_cpu ( int batch , int w1 , int h1 , int c1 , float * add , int w2 , int h2 , int c2 , float s1 , float s2 , float * out ) { int stride = w1 / w2 ; int sample = w2 / w1 ; assert ( stride == h1 / h2 ) ; assert ( sample == h2 / h1 ) ; if ( stride < 1 ) stride = 1 ; if ( sample < 1 ) sample = 1 ; int minw = ( w1 < w2 ) ? w1 : w2 ; int minh = ( h1 < h2 ) ? h1 : h2 ; int minc = ( c1 < c2 ) ? c1 : c2 ; int i , j , k , b ; for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < minc ; ++ k ) { for ( j = 0 ; j < minh ; ++ j ) { for ( i = 0 ; i < minw ; ++ i ) { int out_index = i * sample + w2 * ( j * sample + h2 * ( k + c2 * b ) ) ; int add_index = i * stride + w1 * ( j * stride + h1 * ( k + c1 * b ) ) ; out [ out_index ] = s1 * out [ out_index ] + s2 * add [ add_index ] ; } } } } }
void get_before_nms_data_cpu ( const float * boxes , const float * scores , const int * labels , const int * index , float * boxes_out , float * scores_out , int * labels_out , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( index [ tid ] == 0 ) { boxes_out [ tid * 4 + 0 ] = -1 ; boxes_out [ tid * 4 + 1 ] = -1 ; boxes_out [ tid * 4 + 2 ] = -1 ; boxes_out [ tid * 4 + 3 ] = -1 ; scores_out [ tid ] = -1 ; labels_out [ tid ] = -1 ; } else { boxes_out [ tid * 4 + 0 ] = boxes [ tid * 4 + 0 ] ; boxes_out [ tid * 4 + 1 ] = boxes [ tid * 4 + 1 ] ; boxes_out [ tid * 4 + 2 ] = boxes [ tid * 4 + 2 ] ; boxes_out [ tid * 4 + 3 ] = boxes [ tid * 4 + 3 ] ; scores_out [ tid ] = scores [ tid ] ; labels_out [ tid ] = labels [ tid ] ; } } }
void im2col_cpu ( float * data_im , int channels , int height , int width , int ksize , int stride , int pad , float * data_col ) { int c , h , w ; int height_col = ( height + 2 * pad - ksize ) / stride + 1 ; int width_col = ( width + 2 * pad - ksize ) / stride + 1 ; int channels_col = channels * ksize * ksize ; for ( c = 0 ; c < channels_col ; ++ c ) { int w_offset = c % ksize ; int h_offset = ( c / ksize ) % ksize ; int c_im = c / ksize / ksize ; for ( h = 0 ; h < height_col ; ++ h ) { for ( w = 0 ; w < width_col ; ++ w ) { int im_row = h_offset + h * stride ; int im_col = w_offset + w * stride ; int col_index = ( c * height_col + h ) * width_col + w ; data_col [ col_index ] = im2col_get_pixel ( data_im , height , width , channels , im_row , im_col , c_im , pad ) ; } } } }
void getTopkNum ( const float * inputScore , const int * inputIndex , float * outputScore , int * outputIndex , float threshold , const int dims , int * anchorIndex , int * classIndex , const int classNum , int batchSize , int totalScoreNum ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { for ( int i = 0 ; i < batchSize ; i ++ ) { if ( inputScore [ i * totalScoreNum + tid ] >= threshold ) { outputScore [ i * dims + tid ] = inputScore [ i * totalScoreNum + tid ] ; outputIndex [ i * dims + tid ] = inputIndex [ i * totalScoreNum + tid ] ; anchorIndex [ i * dims + tid ] = outputIndex [ i * dims + tid ] / classNum ; classIndex [ i * dims + tid ] = outputIndex [ i * dims + tid ] % classNum ; } else { outputScore [ i * dims + tid ] = 0.0f ; outputIndex [ i * dims + tid ] = -1 ; anchorIndex [ i * dims + tid ] = -1 ; classIndex [ i * dims + tid ] = -1 ; } } } }
void fractal_cpu ( const int width , const int frames , unsigned char * const pic ) { for ( int i = 0 ; i < width * width * frames ; i ++ ) { const float Delta = 0.00304f ; const float xMid = -0.055846456f ; const float yMid = -0.668311119f ; const int frame = i / ( width * width ) ; float delta = Delta * powf ( 0.975f , frame ) ; const int col = i % width ; const float xMin = xMid - delta ; const float yMin = yMid - delta ; const float dw = 2.0f * delta / width ; const int row = ( i / width ) % width ; const float cy = yMin + row * dw ; const float cx = xMin + col * dw ; float x = cx ; float y = cy ; float x2 , y2 ; int count = 256 ; do { x2 = x * x ; y2 = y * y ; y = 2.0 * x * y + cy ; x = x2 - y2 + cx ; count -- ; } while ( ( count > 0 ) && ( ( x2 + y2 ) <= 5.0 ) ) ; pic [ frame * width * width + row * width + col ] = ( unsigned char ) count ; } }
void bit8Channels_cpu ( unsigned char * out , unsigned char * in , int channel , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int firstIndexToGrab = i * 8 ; unsigned char bit0 = ( in [ firstIndexToGrab + 0 ] & 0x01 ) << 0 ; unsigned char bit1 = ( in [ firstIndexToGrab + 1 ] & 0x01 ) << 1 ; unsigned char bit2 = ( in [ firstIndexToGrab + 2 ] & 0x01 ) << 2 ; unsigned char bit3 = ( in [ firstIndexToGrab + 3 ] & 0x01 ) << 3 ; unsigned char bit4 = ( in [ firstIndexToGrab + 4 ] & 0x01 ) << 4 ; unsigned char bit5 = ( in [ firstIndexToGrab + 5 ] & 0x01 ) << 5 ; unsigned char bit6 = ( in [ firstIndexToGrab + 6 ] & 0x01 ) << 6 ; unsigned char bit7 = ( in [ firstIndexToGrab + 7 ] & 0x01 ) << 7 ; unsigned char output = bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 ; int outputIndex = i * 8 + channel - 1 ; out [ outputIndex ] = output ; } }
void * Match ( int num_points , float * P , float * Q , int q_points , int * idx , int start , int end ) { float dist ; float max_dist = 1000000000.0f ; for ( int i = start ; i < end ; i ++ ) { max_dist = 1000000000.0f ; for ( int j = 0 ; j < num_points ; j ++ ) { dist = ( P [ 0 + i * 3 ] - Q [ 0 + j * 3 ] ) * ( P [ 0 + i * 3 ] - Q [ 0 + j * 3 ] ) + ( P [ 1 + i * 3 ] - Q [ 1 + j * 3 ] ) * ( P [ 1 + i * 3 ] - Q [ 1 + j * 3 ] ) + ( P [ 2 + i * 3 ] - Q [ 2 + j * 3 ] ) * ( P [ 2 + i * 3 ] - Q [ 2 + j * 3 ] ) ; if ( dist < max_dist ) { max_dist = dist ; idx [ i ] = j ; } } } return ( void * ) 0 ; }
void col2im_cpu ( float * data_col , int channels , int height , int width , int ksize , int stride , int pad , float * data_im ) { int c , h , w ; int height_col = ( height + 2 * pad - ksize ) / stride + 1 ; int width_col = ( width + 2 * pad - ksize ) / stride + 1 ; int channels_col = channels * ksize * ksize ; for ( c = 0 ; c < channels_col ; ++ c ) { int w_offset = c % ksize ; int h_offset = ( c / ksize ) % ksize ; int c_im = c / ksize / ksize ; for ( h = 0 ; h < height_col ; ++ h ) { for ( w = 0 ; w < width_col ; ++ w ) { int im_row = h_offset + h * stride ; int im_col = w_offset + w * stride ; int col_index = ( c * height_col + h ) * width_col + w ; float val = data_col [ col_index ] ; col2im_add_pixel ( data_im , height , width , channels , im_row , im_col , c_im , pad , val ) ; } } } }
void yuv2rgb_kernel ( int img_size , unsigned char * gpu_img_in_y , unsigned char * gpu_img_in_u , unsigned char * gpu_img_in_v , unsigned char * gpu_img_out_r , unsigned char * gpu_img_out_g , unsigned char * gpu_img_out_b ) { int rt , gt , bt ; int rt2 , gt2 , bt2 ; int index ; for ( index = 0 ; index < img_size ; index ++ ) { rt = ( int ) ( gpu_img_in_y [ index ] + 1.402 * ( gpu_img_in_v [ index ] - 128 ) ) ; gt = ( int ) ( gpu_img_in_y [ index ] - 0.344 * ( gpu_img_in_u [ index ] - 128 ) - 0.714 * ( gpu_img_in_v [ index ] - 128 ) ) ; bt = ( int ) gpu_img_in_y [ index ] + 1.772 * ( gpu_img_in_u [ index ] - 128 ) ; rt2 = ( rt > 255 ) ? 255 : rt ; gt2 = ( gt > 255 ) ? 255 : gt ; bt2 = ( bt > 255 ) ? 255 : bt ; gpu_img_out_r [ index ] = ( rt2 < 0 ) ? 0 : rt2 ; gpu_img_out_b [ index ] = ( bt2 < 0 ) ? 0 : bt2 ; gpu_img_out_g [ index ] = ( gt2 < 0 ) ? 0 : gt2 ; } }
void get_boxes_for_nms_cpu ( const float * boxes_before_nms , const float * offset , float * boxes_for_nms , int dims ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { if ( boxes_before_nms [ tid * 4 + 0 ] == ( -1 ) && boxes_before_nms [ tid * 4 + 1 ] == ( -1 ) && boxes_before_nms [ tid * 4 + 2 ] == ( -1 ) && boxes_before_nms [ tid * 4 + 3 ] == ( -1 ) ) { boxes_for_nms [ tid * 4 + 0 ] = ( -1 ) ; boxes_for_nms [ tid * 4 + 1 ] = ( -1 ) ; boxes_for_nms [ tid * 4 + 2 ] = ( -1 ) ; boxes_for_nms [ tid * 4 + 3 ] = ( -1 ) ; } else { boxes_for_nms [ tid * 4 + 0 ] = boxes_before_nms [ tid * 4 + 0 ] + offset [ tid ] ; boxes_for_nms [ tid * 4 + 1 ] = boxes_before_nms [ tid * 4 + 1 ] + offset [ tid ] ; boxes_for_nms [ tid * 4 + 2 ] = boxes_before_nms [ tid * 4 + 2 ] + offset [ tid ] ; boxes_for_nms [ tid * 4 + 3 ] = boxes_before_nms [ tid * 4 + 3 ] + offset [ tid ] ; } } }
void eltwise_cpu ( int batch , int w1 , int h1 , int c1 , float * add , int w2 , int h2 , int c2 , float * out , int sum , int mult ) { int stride = w1 / w2 ; int sample = w2 / w1 ; assert ( stride == h1 / h2 ) ; assert ( sample == h2 / h1 ) ; if ( stride < 1 ) stride = 1 ; if ( sample < 1 ) sample = 1 ; int minw = ( w1 < w2 ) ? w1 : w2 ; int minh = ( h1 < h2 ) ? h1 : h2 ; int minc = ( c1 < c2 ) ? c1 : c2 ; int i , j , k , b ; if ( mult == 1 ) { for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < minc ; ++ k ) { for ( j = 0 ; j < minh ; ++ j ) { for ( i = 0 ; i < minw ; ++ i ) { int out_index = i * sample + w2 * ( j * sample + h2 * ( k + c2 * b ) ) ; int add_index = i * stride + w1 * ( j * stride + h1 * ( k + c1 * b ) ) ; out [ out_index ] = out [ out_index ] * add [ add_index ] ; } } } } } else if ( sum == 1 ) { for ( b = 0 ; b < batch ; ++ b ) { for ( k = 0 ; k < minc ; ++ k ) { for ( j = 0 ; j < minh ; ++ j ) { for ( i = 0 ; i < minw ; ++ i ) { int out_index = i * sample + w2 * ( j * sample + h2 * ( k + c2 * b ) ) ; int add_index = i * stride + w1 * ( j * stride + h1 * ( k + c1 * b ) ) ; out [ out_index ] = out [ out_index ] + add [ add_index ] ; } } } } } }
void decode_cpu ( const float * anchor , const float * locData , float * predictBox , int dims , float scaleClamp , int batchSize ) { for ( int tid = 0 ; tid < dims ; tid ++ ) { for ( int i = 0 ; i < batchSize ; i ++ ) { float anchorW = anchor [ i * dims * 4 + tid * 4 + 2 ] - anchor [ i * dims * 4 + tid * 4 ] ; float anchorH = anchor [ i * dims * 4 + tid * 4 + 3 ] - anchor [ i * dims * 4 + tid * 4 + 1 ] ; float anchorCx = anchor [ i * dims * 4 + tid * 4 ] + 0.5 * anchorW ; float anchorCy = anchor [ i * dims * 4 + tid * 4 + 1 ] + 0.5 * anchorH ; float dx = locData [ i * dims * 4 + tid * 4 ] ; float dy = locData [ i * dims * 4 + tid * 4 + 1 ] ; float dw = locData [ i * dims * 4 + tid * 4 + 2 ] ; float dh = locData [ i * dims * 4 + tid * 4 + 3 ] ; if ( dw > scaleClamp ) { dw = scaleClamp ; } if ( dh > scaleClamp ) { dh = scaleClamp ; } float preCx = dx * anchorW + anchorCx ; float preCy = dy * anchorH + anchorCy ; float preW = anchorW * 0.5 ; float preH = anchorH * 0.5 ; predictBox [ i * dims * 4 + tid * 4 ] = preCx - 0.5 * preW ; predictBox [ i * dims * 4 + tid * 4 + 1 ] = preCy - 0.5 * preH ; predictBox [ i * dims * 4 + tid * 4 + 2 ] = preCx + 0.5 * preW ; predictBox [ i * dims * 4 + tid * 4 + 3 ] = preCy + 0.5 * preH ; } } }
void nlf_down_forward_cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top_data ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row - 1 ; c = col ; shift = 1 * step + row * width + col ; if ( r >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col - 1 ; shift = 2 * step + row * width + col ; if ( r >= 0 && c >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row - 1 ; c = col + 1 ; shift = 3 * step + row * width + col ; if ( r >= 0 && c < width ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row ; c = col - 1 ; shift = 4 * step + row * width + col ; if ( c >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; top_data [ base + row * width + col ] = temp ; } } } }
void nlf_filter_left_backward_cpu ( const int n , const float * bottom_data , const float * top_data , const float * temp_diff , const int channel , const int height , const int width , const int wsize , float * filters_diff ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index / step * step * channel + index % step ; int fbase = index / step * step * wsize + index % step ; int row = index % step / width ; int col = index % step % width ; for ( int i = 0 ; i < channel ; i ++ ) { filters_diff [ fbase ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col + 1 < width ) filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * top_data [ base + 1 + i * step ] ; else filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col + 1 < width && row - 1 >= 0 ) filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * top_data [ base - width + 1 + i * step ] ; else filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col + 1 < width && row + 1 < height ) filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * top_data [ base + width + 1 + i * step ] ; else filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row + 1 < height ) filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * top_data [ base + width + i * step ] ; else filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; } } }
void nlf_filter_down_backward_cpu ( const int n , const float * bottom_data , const float * top_data , const float * temp_diff , const int channel , const int height , const int width , const int wsize , float * filters_diff ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index / step * step * channel + index % step ; int fbase = index / step * step * wsize + index % step ; int row = index % step / width ; int col = index % step % width ; for ( int i = 0 ; i < channel ; i ++ ) { filters_diff [ fbase ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row - 1 >= 0 ) filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * top_data [ base - width + i * step ] ; else filters_diff [ fbase + step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row - 1 >= 0 && col - 1 >= 0 ) filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * top_data [ base - width - 1 + i * step ] ; else filters_diff [ fbase + 2 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( row - 1 >= 0 && col + 1 < width ) filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * top_data [ base - width + 1 + i * step ] ; else filters_diff [ fbase + 3 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; if ( col - 1 >= 0 ) filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * top_data [ base - 1 + i * step ] ; else filters_diff [ fbase + 4 * step ] += temp_diff [ base + i * step ] * bottom_data [ base + i * step ] ; } } }
void nlf_up_forward_cpu ( const int n , const float * filters , const int channel , const int height , const int width , const int wsize , float * top_data ) { for ( int index = 0 ; index < n ; index ++ ) { int step = height * width ; int base = index * step ; int fbase = index / channel * wsize * step ; for ( int row = height - 1 ; row >= 0 ; row -- ) { for ( int col = width - 1 ; col >= 0 ; col -- ) { float temp = 0 ; int r = row ; int c = col ; int shift = 0 * step + row * width + col ; temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; r = row + 1 ; c = col ; shift = 1 * step + row * width + col ; if ( r < height ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col - 1 ; shift = 2 * step + row * width + col ; if ( r < height && c >= 0 ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row + 1 ; c = col + 1 ; shift = 3 * step + row * width + col ; if ( r < height && c < width ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; r = row ; c = col + 1 ; shift = 4 * step + row * width + col ; if ( c < width ) temp += top_data [ base + r * width + c ] * filters [ fbase + shift ] ; else temp += top_data [ base + row * width + col ] * filters [ fbase + shift ] ; top_data [ base + row * width + col ] = temp ; } } } }
